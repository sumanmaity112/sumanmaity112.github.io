---
layout: post
title: 'Chapter 5: Basic operators of Mono and Flux'
canonical_url: https://medium.com/@suman.maity112/chapter-5-basic-operators-of-mono-and-flux-953531e79ac0?source=rss-92eeb3145de9------2
tag:
- reactive-programming
- software-development
- webflux
- java
- spring-reactive
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*3Xy33t0GCqL7O15SKCHmRg.png" /></figure><p>Now that we understood the building blocks as part of previous chapter, let’s try understand the basic operators and how to use them.</p><h3>Basic operators of Mono</h3><h4>map</h4><p>Mono.map() is mainly used for transformation of data, basically you have some data and when you want to convert the same data to another by applying certain synchronous transformation logic, we can make use of map there.</p><p><strong>Syntax:</strong></p><pre>public final &lt;R&gt; Mono&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</pre><p><strong><em>Example:</em></strong></p><pre>Mono.just(2)<br>    // We&#39;re adding the data (2) with 5,<br>    // so once map executes it&#39;ll transform 2 to 7<br>    .map(number -&gt; number + 5)<br>    .subscribe();</pre><h4>filter</h4><p>Mono.filter() is used to filter out elements if it does not compile with certain condition.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; filter(Predicate&lt;? super T&gt; tester)</pre><p><strong>Example:</strong></p><pre>Mono.just(2)<br>    .map(number -&gt; number + 5)<br>    // Return value if the transformed data is an even number<br>    // otherwise return empty mono. In this case, it&#39;ll return<br>    // an empty mono as 7 is not fully divisible by 2<br>    .filter(number -&gt; number % 2 == 0)<br>    .subscribe();</pre><h4>doOnNext</h4><p>Mono.doOnNext() is used to perform side-effect to the emitted element.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)</pre><p><strong>Example:</strong></p><pre>Mono.just(2)<br>    .map(number -&gt; number * 5)<br>    // It&#39;ll print &quot;The value is 10&quot; on the console<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();</pre><blockquote>Note: <em>doOnNext()</em> get’s invoked only if onNext signal emitted by the Mono.</blockquote><h4>doOnError</h4><p>Mono.doOnError() is used to perform side-effects if mono emits an error signal.</p><p>Additionally, using doOnError method, we can also perform specific side effects for specific kind of error either by directly mentioning the error type or by providing a predicate.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError)<br><br>public final &lt;E extends Throwable&gt; Mono&lt;T&gt; doOnError(Class&lt;E&gt; exceptionType,<br>                                                     Consumer&lt;? super E&gt; onError)<br><br>public final Mono&lt;T&gt; doOnError(Predicate&lt;? super Throwable&gt; predicate,<br>                               Consumer&lt;? super Throwable&gt; onError)</pre><p><strong>Example:</strong></p><pre>// Always log error<br>Mono.just(2)<br>    .map(number -&gt; number / 0)<br>    // Given that `number` can not be divisible by 0, it&#39;ll throw an error<br>    // and will log &quot;Unable to perform task&quot; with error details<br>    // This error will always be logged irrespective of error type<br>    .doOnError(throwable -&gt; log.error(&quot;Unable to perform task&quot;, throwable))<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();<br><br>// log only if ArithmeticException occurs<br>Mono.just(2)<br>    .map(number -&gt; number / 0)<br>    // Given that `number` can not be divisible by 0, it&#39;ll throw an error<br>    // and will log &quot;Unable to perform arithmetic operation&quot; with error details <br>    // as .map(number -&gt; number / 0) will emit ArithmeticException.class. If any<br>    // other type of error occurs, this doOnError will be ignored<br>    .doOnError(ArithmeticException.class, throwable -&gt; log.error(&quot;Unable to perform arithmetic operation&quot;, throwable))<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();<br><br>// log only if exception is not an ArithmeticException<br>Mono.just(2)<br>    .map(number -&gt; number / 0)<br>    // Given that `number` can not be divisible by 0, it&#39;ll throw an error<br>    // ArithmeticException, due to that this doOnError will be ignored.<br>    // In-case of any other type of error, it will log &quot;Unable to perform task&quot; with error details<br>    .doOnError(throwable -&gt; !(throwable instanceof ArithmeticException), throwable -&gt; log.error(&quot;Unable to perform task&quot;, throwable))<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();</pre><blockquote>Note: doOnError<em>()</em> get’s invoked only if <em>onError</em> signal emitted by the Mono. You can also add multiple doOnError method as per your requirement</blockquote><h4>doOnSuccess</h4><p>Mono.doOnSuccess() is used to perform side-effects if mono gets completed successfully.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; doOnSuccess(Consumer&lt;? super T&gt; onSuccess)</pre><p><strong>Example:</strong></p><pre>Mono.just(2)<br>    .map(number -&gt; number * 5)<br>    // It&#39;ll print &quot;The value is 10&quot; on the console<br>    .doOnSuccess(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();</pre><blockquote>Note: <em>doOnSuccess()</em> method can consume null element incase of empty Mono.</blockquote><h4>subscribe</h4><p>As we understood previously, in reactive programming instructions does not gets executed until it’s required, subscribe is one of the way to instruct Mono publisher to start the execution <strong>asynchronously</strong>.</p><p><strong>Syntax:</strong></p><pre>public final Disposable subscribe()<br><br>public final Disposable subscribe(Consumer&lt;? super T&gt; consumer)<br><br>public final Disposable subscribe(@Nullable<br>                                  Consumer&lt;? super T&gt; consumer,<br>                                  @Nullable<br>                                  Consumer&lt;? super Throwable&gt; errorConsumer,<br>                                  @Nullable<br>                                  Runnable completeConsumer)</pre><p><strong>Example:</strong></p><pre>Mono.just(2)<br>    .map(number -&gt; number * 5)<br>    // It&#39;ll print &quot;The value is 10&quot; on the console<br>    .subscribe(number -&gt; log.info(&quot;The value is {}&quot;, number));<br><br>Mono.just(2)<br>    .map(number -&gt; number * 5)<br>    // It&#39;ll log as follows<br>    // The value is 10<br>    // Completed<br>    .subscribe(<br>        number -&gt; log.info(&quot;The value is {}&quot;, number),<br>        throwable -&gt; log.error(&quot;Unable to perform task&quot;, throwable),<br>        () -&gt; log.info(&quot;Completed&quot;)<br>    );</pre><h4>block</h4><p>Mono.block() is similar to Mono.subscribe() method but the main difference is block explicitly holds the main thread indefinitely until the publisher completes. We can also decide the timeout by using Mono.block(Duration timeout) method, if publisher is not complete within the provided time, timeout expires and raise a exception with <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/TimeoutException.html">TimeoutException</a> as cause.</p><blockquote>In case of empty Mono, it’ll return null value. If Mono emits an error signal then the original error will be wrapped in <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html">RuntimeException</a>.</blockquote><p><strong>Syntax:</strong></p><pre>@Nullable<br>public T block()<br><br>@Nullable<br>public T block(Duration timeout)</pre><p><strong>Example:</strong></p><pre>Mono.just(2)<br>    // We&#39;re adding the data (2) with 5,<br>    // so once map executes it&#39;ll transform 2 to 7<br>    .map(number -&gt; number + 5)<br>    .block();</pre><blockquote><strong>It’s not recommend to use </strong><strong>block in reactive programming.</strong></blockquote><h3>Basic operators of Flux</h3><h4>map</h4><p>Flux.map() is used for element transformation using synchronous mapper similar to Mono.map(), but Flux.map() transform all the elements of the Flux</p><p><strong>Syntax:</strong></p><pre>public final &lt;V&gt; Flux&lt;V&gt; map(Function&lt;? super T,? extends V&gt; mapper)</pre><p><strong><em>Example:</em></strong></p><pre>Flux.just(2, 4)<br>    // We&#39;re adding 5 with each element,<br>    // so once map executes it&#39;ll return 7 and 9<br>    .map(number -&gt; number + 5)<br>    .subscribe();</pre><h4>filter</h4><p>Flux.filter() is used to filter out elements if it does not compile with certain condition similar to Mono.filter().</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; filter(Predicate&lt;? super T&gt; p)</pre><p><strong>Example:</strong></p><pre>Flux.just(2, 7, 3, 6)<br>    .map(number -&gt; number + 5)<br>    // If the transformed element is an even number<br>    // emit the element otherwise ignore.<br>    // In this case, it&#39;ll return 12, 8<br>    .filter(number -&gt; number % 2 == 0)<br>    .subscribe();</pre><h4>doOnNext</h4><p>Mono.doOnNext() is used to perform side-effect to the each emitted elements.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; doOnNext(Consumer&lt;? super T&gt; onNext)</pre><p><strong>Example:</strong></p><pre>Flux.just(2, 7, 3, 6)<br>    .map(number -&gt; number + 5)<br>    // It&#39;ll print the following lines on console <br>    // &quot;The value is 7&quot;<br>    // &quot;The value is 12&quot;<br>    // &quot;The value is 8&quot;<br>    // &quot;The value is 11&quot;<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();</pre><blockquote>Note: <em>doOnNext()</em> get’s invoked only if <em>onNext</em> signal emitted by the Flux. Incase of empty Flux, <em>doOnNext will be skipped.</em></blockquote><h4>doOnError</h4><p>Flux.doOnError() is used to perform side-effects for error signal similar to Mono.doOnError(). The main difference is Flux can emit more than one onError signal based on error handling (we’ll deep dive in later chapters). By default, on first onError signal, Flux stops processing for other remaining elements.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; doOnError(Consumer&lt;? super Throwable&gt; onError)<br><br>public final &lt;E extends Throwable&gt; Flux&lt;T&gt; doOnError(Class&lt;E&gt; exceptionType,<br>                                                     Consumer&lt;? super E&gt; onError)<br><br>public final Flux&lt;T&gt; doOnError(Predicate&lt;? super Throwable&gt; predicate,<br>                               Consumer&lt;? super Throwable&gt; onError)</pre><p><strong>Example:</strong></p><pre>// Always log error<br>Flux.just(10, 0, 3)<br>    .map(number -&gt; 20 / number)<br>    // Here it&#39;ll first process `20/10` and log &quot;The value is 2&quot;<br>    // post that it&#39;ll try to process for `20`. Given that `20` can not be divisible by `0`,<br>    // it&#39;ll throw an error and will log &quot;Unable to perform task&quot; with error details<br>    // This error will always be logged irrespective of error type<br>    .doOnError(throwable -&gt; log.error(&quot;Unable to perform task&quot;, throwable))<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();<br><br>// log only if ArithmeticException occurs<br>Flux.just(10, 0, 3)<br>    .map(number -&gt; 20 / number)<br>    // Here it&#39;ll first process `20/10` and log &quot;The value is 2&quot;<br>    // post that it&#39;ll try to process for `20`. Given that `20` can not be divisible by `0`,<br>    // it&#39;ll throw an error of ArithmeticException.class and<br>    // will log &quot;Unable to perform arithmetic operation&quot; with error details. If any<br>    // other type of error occurs, this doOnError will be ignored<br>    .doOnError(ArithmeticException.class, throwable -&gt; log.error(&quot;Unable to perform arithmetic operation&quot;, throwable))<br>    .doOnError(throwable -&gt; log.error(&quot;Unable to perform task&quot;, throwable))<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();<br><br>// log only if exception is not an ArithmeticException<br>Flux.just(10, 0, 3)<br>    .map(number -&gt; 20 / number)<br>    // Here it&#39;ll first process `20/10` and log &quot;The value is 2&quot;<br>    // post that it&#39;ll try to process for `20`. Given that `20` can not be divisible by `0`,<br>    // it&#39;ll throw an error of ArithmeticException, due to that this doOnError will be ignored.<br>    // In-case of any other type of error, it will log &quot;Unable to perform task&quot; with error details<br>    .doOnError(throwable -&gt; !(throwable instanceof ArithmeticException), throwable -&gt; log.error(&quot;Unable to perform task&quot;, throwable))<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .subscribe();</pre><blockquote>Note: <em>doOnError()</em> get’s invoked only if <em>onError</em> signal emitted by the Flux. You can also add multiple <em>doOnError</em> method as per your requirement</blockquote><h4>doOnComplete</h4><p>Flux.doOnComplete() is used to perform side-effects if Flux gets completed successfully.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; doOnComplete(Runnable onComplete)</pre><p><strong>Example:</strong></p><pre>Flux.just(10, 0, 3)<br>    .map(number -&gt; 20 * number)<br>    // Here the logs will be as follows<br>    // The value is 200<br>    // The value is 0<br>    // The value is 60<br>    // Process completed<br>    .doOnNext(number -&gt; log.info(&quot;The value is {}&quot;, number))<br>    .doOnComplete(() -&gt; log.info(&quot;Process completed&quot;))<br>    .subscribe();</pre><h4>subscribe</h4><p>Flux.subscribe() is similar to Mono.subscribe(), used to instruct Flux publisher to start execution <strong>asynchronously</strong>.</p><p><strong>Syntax:</strong></p><pre>public final Disposable subscribe()<br><br>public final Disposable subscribe(Consumer&lt;? super T&gt; consumer)<br><br>public final Disposable subscribe(@Nullable<br>                                  Consumer&lt;? super T&gt; consumer,<br>                                  @Nullable<br>                                  Consumer&lt;? super Throwable&gt; errorConsumer,<br>                                  @Nullable<br>                                  Runnable completeConsumer)</pre><p><strong>Example:</strong></p><pre>Flux.just(2, 4)<br>    .map(number -&gt; number * 5)<br>    // It&#39;ll log as follows<br>    // The value is 10<br>    // The value is 20<br>    .subscribe(number -&gt; log.info(&quot;The value is {}&quot;, number));<br><br>Flux.just(2, 4)<br>    .map(number -&gt; number * 5)<br>    // It&#39;ll log as follows<br>    // The value is 10<br>    // The value is 20<br>    // Completed<br>    .subscribe(<br>        number -&gt; log.info(&quot;The value is {}&quot;, number),<br>        throwable -&gt; log.error(&quot;Unable to perform task&quot;, throwable),<br>        () -&gt; log.info(&quot;Completed&quot;)<br>    );</pre><h4>Conclusion</h4><p>In this article, we explored essential operators such as map, filter, and doOnNext, among others. Proficiency in these core concepts establishes a sturdy groundwork for developing scalable and responsive applications in today’s software landscape. While we’ve covered key operators for Mono and Flux publishers, there are many more to discover in subsequent parts of this series.</p><blockquote><em>This article is a segment of the </em><strong><em>Cooking up Reactivity: The Spring Way </em></strong><em>series. To explore the entire series, </em><a href="https://medium.com/@suman.maity112/list/cooking-up-reactivity-the-spring-way-0f5795367dfa"><em>click here</em></a><em>.</em></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=953531e79ac0" width="1" height="1" alt="">
