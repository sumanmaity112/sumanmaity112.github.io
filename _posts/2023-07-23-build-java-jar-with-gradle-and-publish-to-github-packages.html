---
layout: post
title: Build Java jar with Gradle and publish to GitHub packages
canonical_url: https://medium.com/@suman.maity112/build-java-jar-with-gradle-and-publish-to-github-packages-31b3caeb1895?source=rss-92eeb3145de9------2
tag:
- java
- jar
- github-package
- github-actions
- gradle
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*urVi4ybDiLVbiOc0PlNEiA.png" /></figure><p>If you have been working with Java for some time, you might have come across some scenarios where you wanted to publish source code as a jar file so it could be reused in other projects. In this scenario, there are mainly two parts: first, we need to build a jar file, and second, we need to publish the public or private repository, like Maven, GitHub packages, etc. As part of this article, let’s try to understand how we can build library jars with Gradle and publish the same to GitHub packages.</p><h3>How to build Jar</h3><p>There are different kinds of jar files, depending on the packaging technique—</p><ol><li><strong>Skinny</strong> — Contains only the business logic, literally whatever you typed in the code editor.</li><li><strong>Thin</strong> — In addition to Skinny Jar contents, it contains direct dependency as well. But it won’t contain anything related to the application runtime (example: application server).</li><li><strong>Hollow</strong> — It is the exact opposite of a thin jar. It contains everything related to the application runtime but doesn’t contain the app itself. Basically, it contains a pre-packaged “app server” on which apps can be deployed at a later point in time. This packaging technique is very similar to traditional Java EE app servers.</li><li><strong>Fat/Uber </strong>— It’s a self-sufficient jar that contains everything that needs to run the application on its own.</li></ol><figure><img alt="" src="https://cdn-images-1.medium.com/max/712/1*9n4ADuxivWROLvI2eLHJSA.png" /></figure><p>As part of this article, we’ll try to understand how we can build Thin jars with Gradle.</p><pre>import java.text.SimpleDateFormat<br><br>jar {<br>    duplicatesStrategy = DuplicatesStrategy.EXCLUDE<br><br>    manifest {<br>        attributes(<br>                &#39;Implementation-Vendor&#39;: project.group,<br>                &#39;Implementation-Title&#39;: project.name,<br>                &#39;Implementation-Version&#39;: project.version,<br>                &#39;Built-By&#39;: System.properties[&#39;user.name&#39;],<br>                &#39;Created-By&#39;: &quot;Gradle ${gradle.gradleVersion}&quot;,<br>                &#39;Build-Timestamp&#39;: new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ&quot;).format(new Date()),<br>                &#39;Build-Jdk&#39;: &quot;${System.properties[&#39;java.version&#39;]} (${System.properties[&#39;java.vendor&#39;]} ${System.properties[&#39;java.vm.version&#39;]})&quot;,<br>                &#39;Build-OS&#39;: &quot;${System.properties[&#39;os.name&#39;]} ${System.properties[&#39;os.arch&#39;]} ${System.properties[&#39;os.version&#39;]}&quot;<br>        )<br>    }<br><br>    from {<br>        configurations.runtimeClasspath.findAll { it.name.endsWith(&#39;jar&#39;) }.collect { zipTree(it) }<br>    }<br><br>    exclude &#39;META-INF/*.RSA&#39;<br>    exclude &#39;META-INF/*.SF&#39;<br>    exclude &#39;META-INF/*.DSA&#39;<br>}</pre><p>We can add the above code snippet to build.gradle and we can run ./gradlew jar to build the jar file.</p><blockquote>Note: Here we added a couple of attributes to the manifest, these attributes are optional, but it’s good practice to have them.</blockquote><h3>Publish Jar to GitHub Packages</h3><p>Once we have built the jar file, we can publish it to a public or private library repository like Maven or GitHub packages so that it can be reused in other projects. But as part of this article, let’s try to understand how we can publish it to GitHub Packages —</p><pre>apply plugin: &#39;maven-publish&#39;<br><br>publishing {<br>    repositories {<br>        maven {<br>            name = &quot;GitHubPackages&quot;<br>            url = &quot;https://maven.pkg.github.com/&lt;organization/username&gt;/&lt;repository name&gt;&quot;<br>            credentials {<br>                username = &quot;&lt;username&gt;&quot; // System.getenv(&quot;USERNAME&quot;)<br>                password = &quot;&lt;password&gt;&quot; // System.getenv(&quot;PASSWORD&quot;)<br>            }<br>        }<br>    }<br><br>    publications {<br>        gpr(MavenPublication) {<br>            from components.java<br>            groupId = project.group<br>            artifactId = project.name<br>            version = project.version<br>        }<br>    }<br>}</pre><p>We can add the above code snippet to build.gradle, and we can run ./gradlew publishToMavenLocal to publish the library to the local Maven repository (m2 cache), generally it presents at &lt;user home folder&gt;/.m2/repository. Once it’s published to the local m2 cache, we can verify the package by using it in some other project locally. Once we are happy with the result, we can run ./gradlew publish to publish the library to GitHub packages.</p><h4>Publish Jar to GitHub Packages using GitHub Action</h4><p>In the above code snippet, we published the jar from the local system using the user’s username and password or token. But if you are already using GitHub actions for CI/CD, we can use the workflow to publish the jar to GitHub packages <strong><em>without using personal credentials</em></strong>.</p><pre># build-and-publish.yml<br><br>name: build and publish<br><br>on:<br>  push:<br>    branches: [ main ]<br>    tags:<br>      - &#39;v*.*.*&#39; # We will publish new version for tag which follows &#39;v*.*.*&#39; format<br><br>env:<br>  SERVICE_NAME: hello-world<br><br>jobs:<br>  verification:<br>    runs-on: ubuntu-22.04<br>    steps:<br>      - name: Checkout local repository<br>        uses: actions/checkout@v3<br>        with:<br>          path: ${{ github.workspace }}/${{ env.SERVICE_NAME }}<br>      - uses: actions/setup-java@v3<br>        with:<br>          distribution: &#39;temurin&#39; # Here we are using temurin java distribution but can be customized depends on the requirement<br>          java-version: &#39;17&#39; # Here we are using java 17 but can be customized depends on the requirement<br>          cache: &#39;gradle&#39; # Here are enabling gradle cache to cache gradle wrappers, dependencies etc. It can be disabled by simply removing the line<br>      - name: Run all tests<br>        run: ./gradlew clean check --no-daemon<br>        working-directory: ${{ github.workspace }}/${{ env.SERVICE_NAME }}/<br>      <br>  determine_should_publish_new_version: # Publish new version for new tags<br>    runs-on: ubuntu-22.04<br>    outputs:<br>      PUBLISH_NEW_VERSION: ${{ steps.determine_should_publish_new_version.outputs.PUBLISH_NEW_VERSION }}<br>    steps:<br>      - name: Checkout local repository<br>        uses: actions/checkout@v3<br>      - name: Determine should publish docker image<br>        id: determine_should_publish_new_version<br>        run: |<br>          PUBLISH_NEW_VERSION=false<br>          if [[ $(git tag --points-at HEAD) != &#39;&#39; ]]; then<br>            PUBLISH_NEW_VERSION=true<br>          fi<br>          echo &quot;PUBLISH_NEW_VERSION=${PUBLISH_NEW_VERSION}&quot; &gt;&gt; $GITHUB_OUTPUT<br><br>  publish-jar:<br>    runs-on: ubuntu-22.04<br>    needs: [ determine_should_publish_new_version, verification ]<br>    if: ${{ needs.determine_should_publish_new_version.outputs.PUBLISH_NEW_VERSION == &#39;true&#39; }}<br>    permissions:<br>      contents: read<br>      packages: write<br>    steps:<br>      - name: Checkout local repository<br>        uses: actions/checkout@v3<br>        with:<br>          path: ${{ github.workspace }}/${{ env.SERVICE_NAME }}<br>      - uses: actions/setup-java@v3<br>        with:<br>          distribution: &#39;temurin&#39;<br>          java-version: &#39;17&#39;<br>          cache: &#39;gradle&#39;<br>      - name: Publish jar<br>        run: ./gradlew publish --no-daemon<br>        working-directory: ${{ github.workspace }}/${{ env.SERVICE_NAME }}/<br>        env:<br>          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</pre><pre>apply plugin: &#39;maven-publish&#39;<br><br>publishing {<br>    repositories {<br>        maven {<br>            name = &quot;GitHubPackages&quot;<br>            url = &quot;https://maven.pkg.github.com/&lt;organization/username&gt;/&lt;repository name&gt;&quot;<br>            credentials {<br>                username = System.getenv(&quot;GITHUB_ACTOR&quot;)<br>                password = System.getenv(&quot;GITHUB_TOKEN&quot;)<br>            }<br>        }<br>    }<br><br>    publications {<br>        gpr(MavenPublication) {<br>            from components.java<br>            groupId = project.group<br>            artifactId = project.name<br>            version = project.version<br>        }<br>    }<br>}</pre><p>Using the above code snippets, we’ll be able to publish the jar to GitHub packages using the GitHub action.</p><h3>Conclusion</h3><p>As part of this article, we have built Thin Jar and published the same to GitHub packages. But similar concepts can be used to build other types of jar files and publish them to other repositories, like Maven Central.</p><p><em>PS: I hope you’ve enjoyed it, and if you’ve found it useful, please feel free to share it with others or leave a comment.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=31b3caeb1895" width="1" height="1" alt="">
