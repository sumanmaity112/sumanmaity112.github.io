---
layout: post
title: Reduce build time by running tests in parallel
canonical_url: https://medium.com/@suman.maity112/reduce-build-time-by-running-tests-in-parallel-ec0d26f068a6?source=rss-92eeb3145de9------2
tag:
- junit-5
- parallel-testing
- integration-testing
- java
- gradle
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/552/1*FwCF8-1W_1Sb9Zo_PvLJHw.png" /></figure><p>If youâ€™ve been working on large projects, you might have observed that the build time increases with the number of features. Initially, it might have taken only a couple of seconds, but slowly, it increased to long minutes. Due to this, we sometimes try to avoid adding new tests or running them locally while developing. If we donâ€™t add new tests, it might introduce bugs in theÂ future.</p><p>As part of this blog, Iâ€™ll focus on how to reduce build time for Java projects. But before we start looking for solutions, letâ€™s try to look into the problem. When we add new code to the codebase, we also add multiple layers of tests (for example, unit tests, integration tests, and so on). When we have lots of tests, itâ€™ll take longer to complete the tests. So, now that the easy solution comes to our mind, letâ€™s run tests in parallel instead of sequential. Yes, itâ€™ll solve the problem, but the question is, how can we run tests in parallel? ðŸ¤”</p><h3>Running tests inÂ parallel</h3><h4>with Gradle</h4><p>If you are using <a href="https://gradle.org/">gradle</a>, we can run tests in parallel by adding following configuration â€”</p><pre>// build.gradle <br>test {<br>    useJUnitPlatform() {}<br><br>    minHeapSize=&quot;128m&quot;<br>    maxHeapSize=&quot;1024m&quot;<br><br>    // Use half of available processor to run tests in parallel.<br>    // The following maxParallelForks config is suggested by gradle itself, https://docs.gradle.org/current/userguide/performance.html#execute_tests_in_parallel<br><br>    maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1<br><br>    reports.html.required = true<br>}</pre><h4>With JunitÂ 5</h4><p>If you are using Junit 5, you also can run tests in parallel by simply adding the following config <strong><em>junit-platform.properties</em></strong> file</p><pre># junit-platform.properties<br><br>junit.jupiter.execution.parallel.enabled=true<br>junit.jupiter.execution.parallel.config.strategy=dynamic<br>junit.jupiter.execution.parallel.mode.default=same_thread<br>junit.jupiter.execution.parallel.mode.classes.default=concurrent</pre><p>With Junit, you can configure the concurrency level according to your need. Check the following image to understand the effect of junit.jupiter.execution.parallel.mode.default and junit.jupiter.execution.parallel.mode.classes.default config.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*DzjnIgs-UMzHMeo0XvAYUg.png" /><figcaption>Junit concurrency config</figcaption></figure><p>You can read more about the Junit config on <a href="https://junit.org/junit5/docs/snapshot/user-guide/#writing-tests-parallel-execution">their documentation</a>.</p><blockquote>Personally I prefer to setjunit.jupiter.execution.parallel.mode.default to same_thread and junit.jupiter.execution.parallel.mode.classes.default to concurrent. Even though it might take more time than running all tests concurrently (when both are set to concurrent), it easy to maintain in longÂ run.</blockquote><p>With the above configuration, the tests started being executed in parallel, which works well for unit tests. But it might not work for integration tests, especially for Spring Boot integration tests annotated with @DirtiesContext. Currently, Junit doesnâ€™t support parallel execution for integration tests. So, if we want to use Junit for parallel execution of integration tests, we need to make someÂ changes.</p><h4>Tweaks to use Junit to execute integration tests inÂ parallel</h4><p>Currently, Junit doesnâ€™t support parallel execution as itâ€™s tries to reuse context cache and there is no way to disable it. So, to simulate @DirtiesContext effect we need to create a new context cache key for each test class. The simplest way to generate a context key is to activate new random profile for each test class. Now the question is how can we activate a random profile?Â ðŸ¤”</p><p>We can do by using @ActiveProfiles annotation but we need to pass a custom resolver, something like following â€”</p><pre>// CustomActiveProfilesResolver.java<br><br>package com.suman;<br><br>import java.util.Arrays;<br>import java.util.stream.Stream;<br>import org.springframework.test.context.support.DefaultActiveProfilesResolver;<br>import org.apache.commons.lang3.RandomStringUtils;<br><br>public class CustomActiveProfilesResolver extends DefaultActiveProfilesResolver {<br>  @Override<br>  public String[] resolve(Class&lt;?&gt; testClass) {<br>    return Stream.concat(<br>            Stream.of(testclass.getName().hashCode()),<br>            Arrays.stream(super.resolve(testClass)))<br>        .toArray(String[]::new);<br>  }<br>}</pre><blockquote>You can use random string instead of hashCode(), but random string might not work for Nested test classes depends on project structure.</blockquote><p>So if we put everything together then itâ€™ll look something like following â€”</p><pre>// HelloWorldIntegrationTest.java<br><br>package com.suman.hello;<br><br>import org.junit.jupiter.api.Test;<br>import org.springframework.boot.test.context.SpringBootTest;<br>import org.springframework.test.annotation.DirtiesContext;<br>import org.springframework.test.context.ActiveProfiles;<br>import com.suman.CustomActiveProfilesResolver;<br><br>@DirtiesContext<br>@ActiveProfiles(value = &quot;test&quot;, resolver = CustomActiveProfilesResolver.class)<br>@SpringBootTest(webEnvironment = RANDOM_PORT)<br>class HelloWorldIntegrationTest {<br><br>  @Test<br>  void shouldAbc(){<br>    // ...<br>  }<br><br>  @Test<br>  void shouldAbcd(){<br>    // ...<br>  }<br>}</pre><p>Now with the above tweaks we can run our integration tests in parallel.</p><h3>Running tests with common infra/data dependency</h3><p>With all the above configurations, we were able to execute all tests (including integration tests) in parallel, but it creates issues once we have a dependency on some infrastructure orÂ data.</p><p>For example, if we have database dependencies or are using tools to mock cloud infrastructure dependencies, we want the dependencies to be clean for each test; otherwise, weâ€™ll face inconsistencies with the testÂ results.</p><p>Here is the simplest option to have separate dependency instances, like a separate database and/or separate cloud infrastructure, for each class. So, now the question is how can we create separate cloud infrastructure or databases? ðŸ¤”</p><p>Here also, weâ€™ll use our previous idea; weâ€™ll create a random string and use the same random string as a prefix/suffix for each resource related to a specific test class. To achieve this automatically, we need to make a couple of changesÂ â€”</p><ul><li>We will make use of the properties file (ex: <strong><em>application.properties</em></strong>) to pass all the names for common resources.</li><li>Once we have moved all the hardcoded names from the Java file to the properties file, we will use the ApplicationContextInitializer to update the values for the required properties. We can use the @ContextConfiguration annotation to provide the custom context initializer.</li></ul><p>So, if we put everything together, our new tweaks will look something like the following â€”</p><pre>// ConfigRandomizer.java<br><br>package com.suman;<br><br>import lombok.extern.slf4j.Slf4j;<br>import org.springframework.boot.test.util.TestPropertyValues;<br>import org.springframework.context.ApplicationContextInitializer;<br>import org.springframework.context.ConfigurableApplicationContext;<br>import org.springframework.core.env.ConfigurableEnvironment;<br>import org.testcontainers.shaded.org.apache.commons.lang3.RandomStringUtils;<br><br>import java.util.AbstractMap;<br>import java.util.List;<br>import java.util.Map;<br>import java.util.stream.Collectors;<br><br>@Slf4j<br>public class ConfigRandomizer<br>    implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {<br>  private static final List&lt;String&gt; CONFIG_TO_BE_RANDOMIZED =<br>      List.of(&quot;app.table.name&quot;, &quot;app.config.random.prefix&quot;);<br><br>  @Override<br>  public void initialize(ConfigurableApplicationContext applicationContext) {<br>    final ConfigurableEnvironment environment = applicationContext.getEnvironment();<br>    final String prefix = RandomStringUtils.randomAlphabetic(5).toLowerCase();<br><br>    log.info(&quot;===================== Using {} as prefix&quot;, prefix);<br><br>    final Map&lt;String, String&gt; updateConfig =<br>        CONFIG_TO_BE_RANDOMIZED.stream()<br>            .map(<br>                propertyName -&gt;<br>                    new AbstractMap.SimpleImmutableEntry&lt;&gt;(<br>                        propertyName,  &quot;%s_%s&quot;.formatted(prefix, environment.getProperty(propertyName, &quot;&quot;))))<br>            .collect(<br>                Collectors.toMap(<br>                    AbstractMap.SimpleImmutableEntry::getKey,<br>                    AbstractMap.SimpleImmutableEntry::getValue));<br><br>    TestPropertyValues.of(updateConfig).applyTo(applicationContext.getEnvironment());<br>  }<br>}</pre><pre>// HelloWorldIntegrationTest.java<br><br>package com.suman.hello;<br><br>import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;<br><br>import org.junit.jupiter.api.Test;<br>import org.springframework.boot.test.context.SpringBootTest;<br>import org.springframework.test.annotation.DirtiesContext;<br>import org.springframework.test.context.ActiveProfiles;<br>import org.springframework.test.context.ContextConfiguration;<br>import com.suman.CustomActiveProfilesResolver;<br>import com.suman.ConfigRandomizer;<br><br>@DirtiesContext<br>@ActiveProfiles(value = &quot;test&quot;, resolver = CustomActiveProfilesResolver.class)<br>@ContextConfiguration(initializers = ConfigRandomizer.class)<br>@SpringBootTest(webEnvironment = RANDOM_PORT)<br>class HelloWorldIntegrationTest {<br>  @BeforeEach<br>  void setUp() {<br>    // ... create resources if needed<br>  }<br><br>  @AfterEach<br>  void cleanUp() {<br>    // ... cleanup resources if needed<br>  }<br><br>  @Test<br>  void shouldAbc(){<br>    // ...<br>  }<br><br>  @Test<br>  void shouldAbcd(){<br>    // ...<br>  }<br>}</pre><p>Now with all these changes, our tests should work consistently, and weâ€™ll observe that overall build time isÂ reduced.</p><blockquote>In case you need to find available port for tests, you can make use of org.springframework.test.util.TestSocketUtils.<em>findAvailableTcpPort</em>() and update value in ApplicationContextInitializer.</blockquote><p>Thatâ€™s pretty much whatâ€™s needed to run unit and integration tests in parallel.</p><p>Before I close, one thing I want to highlight is that by executing tests in parallel, weâ€™ll be able to reduce the build execution time, but one thing we need to keep in mind is that parallelization is not a silver bullet. When we observe tests taking longer, we should go back to the code base and make sure we are following the proper <a href="https://martinfowler.com/bliki/TestPyramid.html">TestPyramid</a> concept. Only with the combination of <a href="https://martinfowler.com/bliki/TestPyramid.html">TestPyramid</a> and parallelization will weâ€™ll be able to achieve the desiredÂ outcome.</p><p>I hope these concepts add some extra ammo to your arsenal. Feel free to provide your feedback and opinionsÂ ðŸ˜„.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ec0d26f068a6" width="1" height="1" alt="">
