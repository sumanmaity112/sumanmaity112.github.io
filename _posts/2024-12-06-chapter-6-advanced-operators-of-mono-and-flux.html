---
layout: post
title: 'Chapter 6: Advanced operators of Mono and Flux'
canonical_url: https://medium.com/@suman.maity112/chapter-6-advanced-operators-of-mono-and-flux-884386496825?source=rss-92eeb3145de9------2
tag:
- reactive-programming
- java
- webflux
- spring-reactive
- software-development
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*KmzSMma9Q7aAyYV-o0Fiaw.png" /></figure><p>In the previous chapter, we learnt about some basic fundamentals operator for Mono and Flux. As part of this chapter, we’ll dig deeper and understand some more advanced but essential operators.</p><h3>Advanced Operators of Mono</h3><h4>flatMap</h4><p>Mono.flatMap() is used to transforms the emitted item into another Mono, allowing for asynchronous processing and composition of Mono streams.</p><p><strong>Syntax:</strong></p><pre>public final &lt;R&gt; Mono&lt;R&gt; flatMap(Function&lt;? super T, ? extends Mono&lt;? extends R&gt;&gt; transformer)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .flatMap(str -&gt; Mono.just(&quot;%s World!&quot;.formatted(str)))<br>    .subscribe(System.out::println);<br>// Output: Hello World!</pre><h4>flatMapMany</h4><p>Mono.flatMapMany() is used to transforms a Mono into a Flux by applying a function to each emitted item.</p><p><strong>Syntax:</strong></p><pre>public final &lt;R&gt; Flux&lt;R&gt; flatMapMany(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .flatMapMany(str -&gt; Flux.just(str.split(&quot;&quot;)))<br>    .subscribe(System.out::println);<br>// Output: H<br>//         e<br>//         l<br>//         l<br>//         o</pre><h4>concatWith</h4><p>Mono.concatWith() is used to concatenate the current Mono with another Mono, ensuring that the second Mono is subscribed only after the completion of the first.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; concatWith(Publisher&lt;? extends T&gt; other)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .concatWith(Mono.just(&quot;World!&quot;))<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          World</pre><h4>mergeWith</h4><p>Mono.mergeWith() is used to merge emission of current Mono with the given publisher. The emitted element from the current Mono maybe interleaved with the elements from the publisher.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; mergeWith(Publisher&lt;? extends T&gt; other)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .mergeWith(Mono.just(&quot;World!&quot;))<br>    .subscribe(System.out::println);<br>//  Output: Hello<br>//          World</pre><p>Both mergeWith and concatWith operators in Project Reactor’s Mono class combine data from two Mono sources. They take another Mono and return a new Mono with the combined data. The key difference is in<em> emission order.</em></p><ul><li>mergeWith (<strong>eager</strong>): Subscribes to both sources at once. It emits elements from whichever source is ready first, leading to an unpredictable order in the final output.</li><li>concatWith (<strong>sequential</strong>): Subscribes to the second source only after the first finishes. This ensures elements from the first Mono come before the second, preserving the original order.</li></ul><h4>zip</h4><p>Mono.zip() is used to combine data from multiple Mono sources into a single emission. It achieves this by applying a provided zipper function. In simpler words, Mono.zip is like having a pre-defined recipe for combining Monos in a specific order.</p><p><strong>Syntax:</strong></p><pre>public static &lt;T1, T2, O&gt; Mono&lt;O&gt; zip(Mono&lt;? extends T1&gt; p1, Mono&lt;?<br>   extends T2&gt; p2, BiFunction&lt;? super T1, ? super T2, ? extends O&gt; combinator)<br><br>public static &lt;T1, T2, T3&gt; Mono&lt;Tuple3&lt;T1, T2, T3&gt;&gt; zip(Mono&lt;? extends T1&gt; p1,<br>                                                        Mono&lt;? extends T2&gt; p2,<br>                                                        Mono&lt;? extends T3&gt; p3)</pre><p><strong>Example</strong>:</p><pre>Mono.zip(Mono.just(&quot;Hello&quot;),<br>        Mono.just(&quot;World!&quot;), &quot;%s %s&quot;::formatted)<br>    .subscribe(System.out::println);<br>//  Output: Hello World!<br><br>Mono.zip(Mono.just(&quot;Hello&quot;),<br>        Mono.just(&quot;World!&quot;),<br>        Mono.just(&quot;Hi&quot;))<br>    .subscribe(System.out::println);<br>//  Output: [Hello,World!,Hi]</pre><h4>zipWith</h4><p>Mono.zipWith() acts similar to Mono.zip() but with more flexibility for combining Mono sources. It waits for only the <strong>first</strong> provided Mono to emit a value, then uses the zipper function to determine how to combine it with another source (which can be a static value or a new Mono). This allows for conditional logic and dynamic behaviour. In simpler terms, Mono.zipWith allows to adapt the recipe based on the first Mono and potentially add new Mono dynamically.</p><p><strong>Syntax:</strong></p><pre>public final &lt;T2&gt; Mono&lt;Tuple2&lt;T, T2&gt;&gt; zipWith(Mono&lt;? extends T2&gt; other)<br><br>public final &lt;T2, O&gt; Mono&lt;O&gt; zipWith(Mono&lt;? extends T2&gt; other,<br>   BiFunction&lt;? super T, ? super T2, ? extends O&gt; combinator)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .zipWith(Mono.just(&quot;World!&quot;))<br>    .subscribe(System.out::println);<br>//  Output: [Hello,World!]<br><br>Mono.just(&quot;Hello&quot;)<br>    .zipWith(Mono.just(&quot;World!&quot;), &quot;%s %s&quot;::formatted)<br>    .subscribe(System.out::println);<br>//  Output: Hello World!</pre><h4>defaultIfEmpty</h4><p>Emits a default value if the Mono completes without emitting any items.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; defaultIfEmpty(T defaultV)</pre><p><strong>Example</strong>:</p><pre>Mono.empty()<br>    .defaultIfEmpty(&quot;Default value&quot;)<br>    .subscribe(System.out::println);<br>//  Output: Default value</pre><h4>switchIfEmpty</h4><p>Emits a default value from the given publisher if the Mono completes without emitting any items.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; switchIfEmpty(Mono&lt;? extends T&gt; alternate)</pre><p><strong>Example</strong>:</p><pre>Mono.empty()<br>    .switchIfEmpty(Mono.just(&quot;Default value&quot;))<br>    .subscribe(System.out::println);<br>//  Output: Default value</pre><p>Both switchIfEmpty and defaultIfEmpty is used to provide fallback value incase original Mono is completes without emitting any items. The key difference between both the method is, for defaultIfEmpty the value is already available, on the other hand switchIfEmpty help to switch to a completely different Mono.</p><h4>repeat</h4><p>Repeats the emission of a Mono a specified number of times or indefinitely.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; repeat()<br><br>public final Flux&lt;T&gt; repeat(long numRepeat)<br><br>public final Flux&lt;T&gt; repeat(BooleanSupplier predicate)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .repeat()<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          Hello<br>//          Hello<br>//          Hello<br>//    ..... indefinitely<br>    <br>Mono.just(&quot;Hello&quot;)<br>    .repeat(3)<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          Hello<br>//          Hello<br>//          Hello<br>    <br>Mono.just(&quot;Hello&quot;)<br>    .repeat(() -&gt; Math.random() &lt; 0.5)<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          Hello<br>//          Hello<br>//          Hello<br>//    ..... until Math.random() &gt;= 0.5</pre><h4>retry</h4><p>Automatically retries/re-subscribes a Mono a specified number of times or indefinitely if Mono emit an error signal. This is really helpful to handle error scenarios.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; retry()<br><br>public final Mono&lt;T&gt; retry(long numRetries)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .doOnNext(System.out::println)<br>    .map(str -&gt; {<br>      if (str.equals(&quot;Hello&quot;)) {<br>        throw new RuntimeException(&quot;Error!&quot;);<br>      }<br>      return str;<br>    })<br>    .retry()<br>    .subscribe(System.out::println, System.err::println);<br>// Output: Hello<br>//         Hello<br>//         Hello<br>//         .... indefinitely<br><br>Mono.just(&quot;Hello&quot;)<br>    .doOnNext(System.out::println)<br>    .map(str -&gt; {<br>      if (str.equals(&quot;Hello&quot;)) {<br>        throw new RuntimeException(&quot;Error!&quot;);<br>      }<br>      return str;<br>    })<br>    .retry(2)<br>    .subscribe(System.out::println, System.err::println);<br>// Output: Hello<br>//         Hello<br>//         Hello<br>//         Error: java.lang.RuntimeException: Error!</pre><p><em>Note: we will discuss more real life use cases in later chapters.</em></p><h4>retryWhen</h4><p>retryWhen behaves similar to Mono.retry but it comes with better flexibility. This is really helpful to handle error scenarios conditionally.</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; retryWhen(Retry retrySpec)</pre><p><strong>Example</strong>:</p><pre>Mono.just(&quot;Hello&quot;)<br>    .doOnNext(System.out::println)<br>    .map(str -&gt; {<br>      if (str.equals(&quot;Hello&quot;)) {<br>        throw new RuntimeException(&quot;Error!&quot;);<br>      }<br>      return str;<br>    })<br>    .retryWhen(Retry.indefinitely()<br>        .filter(throwable -&gt; throwable instanceof RuntimeException))<br>    .subscribe(System.out::println, System.err::println);<br>// Output: Hello<br>//         Hello<br>//         Hello<br>//         .... indefinitely</pre><p><em>Note: we will discuss more real life use cases in later chapters.</em></p><h4>defer</h4><p>Mono.defer() is used to create a Mono source dynamically, delaying the creation of the actual Mono until the moment of subscription. As defer use lazy initialization, it helps to improve the performance. Additionally, the lazily initialized Mono can be dynamically constructed based on context.</p><p><strong>Syntax:</strong></p><pre>public static &lt;T&gt; Mono&lt;T&gt; defer(Supplier&lt;? extends Mono&lt;? extends T&gt;&gt; supplier)</pre><p><strong>Example</strong>:</p><pre>Mono.defer(() -&gt; Mono.just(&quot;Hello&quot;))<br>    .subscribe(System.out::println);<br>// Output: Hello<br><br>Mono.defer(() -&gt; Math.random() &gt; 0.5 ? <br>        Mono.just(&quot;Hello&quot;) : <br>        Mono.just(&quot;World&quot;))<br>    .subscribe(System.out::println);<br>// Output: either Hello or World based on the value of Math.random()</pre><h4>contextWrite</h4><p>Flux.contextWrite() is used to manipulate the context associated with a Flux source similar to Mono.contextWrite(). This context can be accessed by downstream operators that might need additional information for processing.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; contextWrite(ContextView contextToAppend)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;John&quot;, &quot;Kurt&quot;)<br>    .contextWrite(Context.of(&quot;traceId&quot;, UUID.randomUUID()))<br>    .subscribe(System.out::println);<br>// Output: John<br>//         Kurt<br><br>Flux.just(&quot;John&quot;, &quot;Kurt&quot;)<br>    .flatMap(username -&gt;<br>        Flux.deferContextual(contextView -&gt;<br>                Mono.just(&quot;%s -&gt; %s&quot;.formatted(username, contextView.get(&quot;userId&quot;))))<br>            .contextWrite(Context.of(&quot;userId&quot;, &quot;user-id-%s&quot;.formatted(username.toLowerCase()))))<br>    .subscribe(System.out::println);<br>// Output: John -&gt; user-id-john<br>//         Kurt -&gt; user-id-kurt</pre><blockquote>To implement <a href="https://logback.qos.ch/manual/mdc.html">MDC</a> in Spring Reactive we need to make use of contextWrite</blockquote><h4>cache</h4><p>Mono.cache() is used to cache (remember) last emitted signal (success value or error) and replays it to future subscribers. This is particularly useful for optimizing performance by avoiding redundant execution of expensive operations represented by the Mono.</p><p>By default, cache remembers the last emitted signal indefinitely but in more advanced uses we can customise it as per the requirements (we will discuss in details in later chapters).</p><p><strong>Syntax:</strong></p><pre>public final Mono&lt;T&gt; cache()<br><br>public final Mono&lt;T&gt; cache(Duration ttl)</pre><p><strong>Example</strong>:</p><pre>final Mono&lt;String&gt; cachedMono = Mono.fromCallable(() -&gt; {<br>      System.out.println(&quot;Simulate a slow operation&quot;);<br>      Thread.sleep(500);<br>      return &quot;World&quot;;<br>    }).cache();<br><br>cachedMono.subscribe(data -&gt; System.out.printf(&quot;First subscription: Hello %s%n&quot;, data));<br>cachedMono.subscribe(data -&gt; System.out.printf(&quot;Second subscription: Hello %s%n&quot;, data));<br>//  Output: Simulate a slow operation<br>//          First subscription: Hello World<br>//          Second subscription: Hello World<br><br><br>final Mono&lt;String&gt; cachedMono = Mono.fromCallable(() -&gt; {<br>  System.out.println(&quot;Simulate a slow operation&quot;);<br>  Thread.sleep(500);<br>  return &quot;World&quot;;<br>}).cache(Duration.ofMillis(200));<br><br>cachedMono.subscribe(data -&gt; System.out.printf(&quot;First subscription: Hello %s%n&quot;, data));<br>Thread.sleep(300);<br>cachedMono.subscribe(data -&gt; System.out.printf(&quot;Second subscription: Hello %s%n&quot;, data));<br>//  Output: Simulate a slow operation<br>//          First subscription: Hello World<br>//          Simulate a slow operation<br>//          Second subscription: Hello World</pre><h3>Advanced Operators of Flux</h3><h4><strong>flatMap</strong></h4><p>Flux.flatMap() is similar to Mono.map() used for transforming elements within a Flux stream and creating a new Flux with potentially more elements.</p><p><strong>Syntax:</strong></p><pre>public final &lt;R&gt; Flux&lt;R&gt; flatMap(Function&lt;? super T, ? extends Publisher&lt;? extends R&gt;&gt; mapper)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .flatMap(str -&gt; Flux.fromArray(str.split(&quot;&quot;)))<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: H<br>//          e<br>//          l<br>//          l<br>//          o<br>//          w<br>//          o<br>//          r<br>//          l<br>//          d</pre><h4>concatWith</h4><p>Flux.concatWith() concatenates two Flux stream, emitting elements from the first Flux until it completes, then emitting elements from the second Flux.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; concatWith(Publisher&lt;? extends T&gt; other)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .concatWith(Flux.just(&quot;Hi&quot;, &quot;Human&quot;))<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          World    <br>//          Hi    <br>//          Human   </pre><h4>mergeWith</h4><p>Flux.mergeWith() concatenates two Flux stream similar to Flux.concatWith(), but the major difference is mergeWith eagerly subscribe both the Flux stream where concatWith sequentially subscribe the Fluxs.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; mergeWith(Publisher&lt;? extends T&gt; other)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;Hello&quot;, &quot;World&quot;).delayElements(Duration.ofMillis(100))<br>    .mergeWith(Flux.just(&quot;Hi&quot;, &quot;Human&quot;))<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hi<br>//          Human<br>//          Hello<br>//          World</pre><h4>zipWith</h4><p>Flux.zipWith() pairs up the latest elements of Flux sequences into a single Tuple whenever each Flux emits an element. Additionally, we can provide combinator to customise the elements pairs up process.</p><p><strong>Syntax:</strong></p><pre>public final &lt;T2&gt; Flux&lt;Tuple2&lt;T, T2&gt;&gt; zipWith(Publisher&lt;? extends T2&gt; source2)<br><br>public final &lt;T2, V&gt; Flux&lt;V&gt; zipWith(Publisher&lt;? extends T2&gt; source2,<br>   final BiFunction&lt;? super T, ? super T2, ? extends V&gt; combinator)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .zipWith(Flux.just(&quot;Hi&quot;, &quot;Human&quot;))<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: [Hello,Hi]<br>//          [World,Human]<br><br>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .zipWith(Flux.just(&quot;Hi&quot;, &quot;Human&quot;), &quot;%s, %s&quot;::formatted)<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello, Hi<br>//          World, Human<br><br>Flux.just(&quot;Hello&quot;)<br>    .zipWith(Flux.just(&quot;Hi&quot;, &quot;Human&quot;))<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: [Hello,Hi]</pre><blockquote>zipWith stops processing when either of the streams emits an error or completes. This ensures the resulting stream&#39;s termination state reflects the first stream to reach that point.</blockquote><h4>defaultIfEmpty</h4><p>Emits a default value if the Flux completes without emitting any items, similar to Mono.defaultIfEmpty().</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; defaultIfEmpty(T defaultV)</pre><p><strong>Example</strong>:</p><pre>Flux.empty()<br>    .defaultIfEmpty(&quot;Default value&quot;)<br>    .subscribe(System.out::println);<br>//  Output: Default value</pre><h4>switchIfEmpty</h4><p>Emits a default value from the given publisher if the Flux completes without emitting any items.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; switchIfEmpty(Publisher&lt;? extends T&gt; alternate)</pre><p><strong>Example</strong>:</p><pre>Flux.empty()<br>    .switchIfEmpty(Flux.just(&quot;Default&quot;, &quot;value&quot;))<br>    .subscribe(System.out::println);<br>//  Output: Default<br>//          value<br><br>Flux.empty()<br>    .switchIfEmpty(Mono.just(&quot;Default value&quot;))<br>    .subscribe(System.out::println);<br>//  Output: Default value</pre><p>Both switchIfEmpty and defaultIfEmpty is used to provide fallback value incase original Flux is completes without emitting any items. The key difference between both the method is, for defaultIfEmpty the value is already available, on the other hand switchIfEmpty help to switch to a completely different Flux.</p><h4>repeat</h4><p>Repeats the emission of a Flux for a specified number of times or indefinitely.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; repeat()<br><br>public final Flux&lt;T&gt; repeat(long numRepeat)<br><br>public final Flux&lt;T&gt; repeat(BooleanSupplier predicate)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .repeat()<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          World<br>//          Hello<br>//          World<br>//          Hello<br>//          World<br>//    ..... indefinitely<br>    <br>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .repeat(2)<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          World<br>//          Hello<br>//          World<br>//          Hello<br>//          World<br>    <br>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .repeat(() -&gt; Math.random() &lt; 0.5)<br>    .doOnNext(System.out::println)<br>    .subscribe();<br>//  Output: Hello<br>//          World<br>//          Hello<br>//          World<br>//          Hello<br>//          World<br>//    ..... until Math.random() &gt;= 0.5</pre><h4>retry</h4><p>Automatically retries/re-subscribes a Flux a specified number of times or indefinitely if Mono emit an error signal. This is really helpful to handle error scenarios.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; retry()<br><br>public final Flux&lt;T&gt; retry(long numRetries)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .doOnNext(System.out::println)<br>    .map(str -&gt; {<br>        throw new RuntimeException(&quot;%s Error!&quot;.formatted(str));<br>    })<br>    .retry()<br>    .subscribe(str -&gt; System.out.printf(&quot;Subscribe consumer %s%n&quot;, str),<br>        System.err::println);<br>// Output: Hello<br>//         Hello<br>//         Hello<br>//         .... indefinitely<br><br>    Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>        .doOnNext(System.out::println)<br>        .map(str -&gt; {<br>          if (str.equals(&quot;World&quot;)) {<br>            throw new RuntimeException(&quot;%s Error!&quot;.formatted(str));<br>          }<br>          return str;<br>        })<br>        .retry(2)<br>        .subscribe(str -&gt; System.out.printf(&quot;Subscribe consumer %s%n&quot;, str),<br>            System.err::println);<br>// Output: Hello<br>//         Subscribe consumer Hello<br>//         World<br>//         Hello<br>//         Subscribe consumer Hello<br>//         World<br>//         Hello<br>//         Subscribe consumer Hello<br>//         World<br>//         java.lang.RuntimeException: World Error!</pre><p><em>Note: we will discuss more real life use cases in later chapters.</em></p><h4>retryWhen</h4><p>retryWhen behaves similar to Flux.retry but it comes with better flexibility. This is really helpful to handle error scenarios conditionally.</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; retryWhen(Retry retrySpec)</pre><p><strong>Example</strong>:</p><pre>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .doOnNext(System.out::println)<br>    .map(str -&gt; {<br>      if (str.equals(&quot;World&quot;)) {<br>        throw new IllegalArgumentException(&quot;%s Error!&quot;.formatted(str));<br>      }<br>      throw new IllegalCallerException(&quot;%s Error!&quot;.formatted(str));<br>    })<br>    .retryWhen(Retry.indefinitely()<br>        .filter(throwable -&gt; throwable instanceof IllegalCallerException))<br>    .subscribe(str -&gt; System.out.printf(&quot;Subscribe consumer %s%n&quot;, str),<br>        System.err::println);<br>// Output: Hello<br>//         Hello<br>//         Hello<br>//         .... indefinitely<br><br>Flux.just(&quot;Hello&quot;, &quot;World&quot;)<br>    .doOnNext(System.out::println)<br>    .map(str -&gt; {<br>      if (str.equals(&quot;World&quot;)) {<br>        throw new IllegalArgumentException(&quot;%s Error!&quot;.formatted(str));<br>      }<br>      throw new IllegalCallerException(&quot;%s Error!&quot;.formatted(str));<br>    })<br>    .retryWhen(Retry.indefinitely()<br>        .filter(throwable -&gt; throwable instanceof IllegalArgumentException))<br>    .subscribe(str -&gt; System.out.printf(&quot;Subscribe consumer %s%n&quot;, str),<br>        System.err::println);<br>// Output: Hello<br>//         java.lang.IllegalCallerException: Hello Error!</pre><p><em>Note: we will discuss more real life use cases in later chapters.</em></p><h4>defer</h4><p>Flux.defer() is used to create a Flux source dynamically, delaying the creation of the actual Flux until the moment of subscription, similar to Mono.defer().</p><p><strong>Syntax:</strong></p><pre>public static &lt;T&gt; Flux&lt;T&gt; defer(Supplier&lt;? extends Publisher&lt;T&gt;&gt; supplier)</pre><p><strong>Example</strong>:</p><pre>Flux.defer(() -&gt; Flux.just(&quot;Hello&quot;, &quot;World&quot;))<br>    .subscribe(System.out::println);<br>//  Output: Hello<br>//          World<br><br>Flux.defer(() -&gt; Math.random() &gt; 0.5 ?<br>        Flux.just(&quot;Hello&quot;, &quot;World&quot;) :<br>        Flux.just(&quot;Hi&quot;, &quot;Human&quot;))<br>    .subscribe(System.out::println);<br>// Output: either Hello World or Hi Human based on the value of Math.random()</pre><h4>cache</h4><p>Flux.cache() is used to cache (remember) last emitted sequences (success value or error) and replays it to future subscribers. This is particularly useful for optimizing performance by avoiding redundant execution of expensive operations represented by the Flux.</p><p>By default, cache remembers the last emitted signal indefinitely but in more advanced uses we can customise it as per the requirements (we will discuss in details in later chapters).</p><p><strong>Syntax:</strong></p><pre>public final Flux&lt;T&gt; cache()<br><br>public final Flux&lt;T&gt; cache(Duration ttl)</pre><p><strong>Example</strong>:</p><pre>final Flux&lt;String&gt; cachedFlux = Flux.just(&quot;John&quot;, &quot;Kurt&quot;)<br>    .doOnNext(username -&gt; System.out.printf(&quot;Original element %s%n&quot;, username))<br>    .delayElements(Duration.ofMillis(500))<br>    .cache();<br><br>cachedFlux.subscribe(data -&gt; System.out.printf(&quot;First subscription: Hello %s%n&quot;, data));<br>cachedFlux.subscribe(data -&gt; System.out.printf(&quot;Second subscription: Hello %s%n&quot;, data));<br>// Output: Original element John<br>//         First subscription: Hello John<br>//         Second subscription: Hello John<br>//         Original element Kurt<br>//         First subscription: Hello Kurt<br>//         Second subscription: Hello Kurt<br><br><br>final Flux&lt;String&gt; cachedFlux = Flux.just(&quot;John&quot;, &quot;Kurt&quot;)<br>    .doOnNext(username -&gt; System.out.printf(&quot;Original element %s%n&quot;, username))<br>    .delayElements(Duration.ofMillis(100))<br>    .cache(Duration.ofMillis(200));<br><br>cachedFlux.subscribe(data -&gt; System.out.printf(&quot;First subscription: Hello %s%n&quot;, data));<br>Thread.sleep(500);<br>cachedFlux.subscribe(data -&gt; System.out.printf(&quot;Second subscription: Hello %s%n&quot;, data));<br>// Output: Original element John<br>//         First subscription: Hello John<br>//         Original element Kurt<br>//         First subscription: Hello Kurt<br>//         Original element John<br>//         Second subscription: Hello John<br>//         Original element Kurt<br>//         Second subscription: Hello Kurt</pre><h3>Conclusion</h3><p>In this article, we’ve explored many powerful operators that can elevate reactive programming skills to new heights. From merging, combining, and transforming data streams to handling errors, retries, and caching, these operators provide the building blocks for creating robust, resilient, and high-performance applications.</p><p>By mastering these operators, you can easily craft reactive pipelines that efficiently handle complex asynchronous scenarios, such as data processing, network communications, and event-driven architectures. Whether you’re building microservices, web applications, or backend systems, the versatility of Mono and Flux operators empowers you to design elegant solutions that scale gracefully and deliver exceptional user experiences.</p><blockquote><em>This article is a segment of the </em><strong><em>Cooking up Reactivity: The Spring Way </em></strong><em>series. To explore the entire series, </em><a href="https://medium.com/@suman.maity112/list/cooking-up-reactivity-the-spring-way-0f5795367dfa"><em>click here</em></a><em>.</em></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=884386496825" width="1" height="1" alt="">
