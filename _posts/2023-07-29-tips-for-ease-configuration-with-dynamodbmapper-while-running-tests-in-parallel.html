---
layout: post
title: Tips for ease configuration with DynamoDBMapper while running tests in parallel
canonical_url: https://medium.com/@suman.maity112/tips-for-ease-configuration-with-dynamodbmapper-while-running-tests-in-parallel-ad31e654047e?source=rss-92eeb3145de9------2
tag:
- integration-testing
- dynamodb
- java
- aws-sdk
- parallel-testing
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/520/1*I7Ms8i8n36qZUwjZraIg0w.png" /></figure><p>As part of <a href="https://medium.com/@suman.maity112/reduce-build-time-by-running-tests-in-parallel-ec0d26f068a6">my previous blog</a>, we understood how can we run integration tests in parallel. Now, as part of this blog, I would like to share my approach when I am trying to run integration tests in parallel with dynamodb.</p><p>Most of my projects I used DynamoDBMapper to interact with dynamodb as DynamoDBMapper hides low level details and provide some fluent APIs. Like me if you have also used DynamoDBMapper to interact with dynamodb, you might have observed we need to use @DynamoDBTable annotation to hard code the table name or we need to pass the table name to each and every method call. Personally I like annotation approach. Now, when try to run tests parallelly, it becomes tricky to modify table name as it’s hardcoded in Java codebase. That is when I started looking deeper in AWS SDK doc and found interesting concept of TableNameOverride config. So, what does it do? Basically, depends on our config it’ll use different table name when making method calls.</p><pre>DynamoDBMapperConfig.builder()<br>          .withTableNameOverride(<br>              DynamoDBMapperConfig.TableNameOverride.withTableNamePrefix(&quot;random_&quot;))<br>          .build();</pre><p>So, with the above config when we make use of dynamoDBMapper.load(PersonDocument.class, id), internally it’ll figure out the table name from PersonDocument (let’s assume persons) and prefix it with random_ and use the updated value for all of it’s process. This way we are able to update the table name without much hassle. But it becomes tricky for code base when we try to use batch operations like batchLoad as this methods returns result as <em>Map&lt;TableName, List of result&gt;</em>. As I mentioned before, due to override, DynamoDBMapper uses updated name for all its process, it’ll provide the result also with updated table name. For example the result will become something like following and our code stops working —</p><pre>{<br>  &quot;random_persons&quot;: [<br>    {<br>      &quot;id&quot;: &quot;1&quot;,<br>      &quot;name&quot;: &quot;John&quot;<br>    }<br>  ]<br>}</pre><p>So, we need to do some tweaks so that when the mapper is returning the result it’ll make use of original table name instead of updated random name. The simplest option is to create a custom dynamoDB mapper by updating the batch operations of actual dynamoDB mapper —</p><pre>@Component<br>public static class TableNameOverriddenDynamoDbMapper extends DynamoDBMapper {<br>  // Add constructors ....<br><br>  @Override<br>  public Map&lt;String, List&lt;Object&gt;&gt; batchLoad(<br>      Map&lt;Class&lt;?&gt;, List&lt;KeyPair&gt;&gt; itemsToGet, DynamoDBMapperConfig config) {<br>    final String tableNamePrefix = config.getTableNameOverride().getTableNamePrefix();<br>    return super.batchLoad(itemsToGet, config).entrySet().stream()<br>        .map(<br>            entry -&gt;<br>                new AbstractMap.SimpleImmutableEntry&lt;&gt;(<br>                    entry.getKey().replace(tableNamePrefix, &quot;&quot;), entry.getValue()))<br>        .collect(<br>            Collectors.toMap(<br>                AbstractMap.SimpleImmutableEntry::getKey,<br>                AbstractMap.SimpleImmutableEntry::getValue));<br>  }<br>}<br></pre><blockquote>Here I have only overridden batchLoad but you can use the same concept for other batch operations as well.</blockquote><p>So, now if we put everything together our new tests codebase will look something like follows —</p><pre>// LocalDynamoConfig.java<br><br>package com.suman.config;<br><br>import com.amazonaws.services.dynamodbv2.AmazonDynamoDBAsync;<br>import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper;<br>import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig;<br>import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig.TableNameOverride;<br>import com.amazonaws.services.dynamodbv2.datamodeling.KeyPair;<br>import org.springframework.beans.factory.annotation.Value;<br>import org.springframework.boot.test.context.TestConfiguration;<br>import org.springframework.stereotype.Component;<br><br>import java.util.AbstractMap;<br>import java.util.List;<br>import java.util.Map;<br>import java.util.stream.Collectors;<br><br>@TestConfiguration<br>public class LocalDynamoConfig {<br><br>  @Component<br>  public static class TableNameOverriddenDynamoDbMapper extends DynamoDBMapper {<br>    public TableNameOverriddenDynamoDbMapper(<br>        AmazonDynamoDBAsync dynamoDBClient,<br>        @Value(&quot;${app.config.random.prefix}&quot;) String tableNamePrefix) {<br>      super(dynamoDBClient, getDynamoDBMapperConfig(tableNamePrefix));<br>    }<br><br>    private static DynamoDBMapperConfig getDynamoDBMapperConfig(String tableNamePrefix) {<br>      return DynamoDBMapperConfig.builder()<br>          .withTableNameOverride(<br>              TableNameOverride.withTableNamePrefix(tableNamePrefix))<br>          .build();<br>    }<br><br>    @Override<br>    public Map&lt;String, List&lt;Object&gt;&gt; batchLoad(<br>        Map&lt;Class&lt;?&gt;, List&lt;KeyPair&gt;&gt; itemsToGet, DynamoDBMapperConfig config) {<br>      final String tableNamePrefix = config.getTableNameOverride().getTableNamePrefix();<br>      return super.batchLoad(itemsToGet, config).entrySet().stream()<br>          .map(<br>              entry -&gt;<br>                  new AbstractMap.SimpleImmutableEntry&lt;&gt;(<br>                      entry.getKey().replace(tableNamePrefix, &quot;&quot;), entry.getValue()))<br>          .collect(<br>              Collectors.toMap(<br>                  AbstractMap.SimpleImmutableEntry::getKey,<br>                  AbstractMap.SimpleImmutableEntry::getValue));<br>    }<br>  }<br>}</pre><pre>// CustomActiveProfilesResolver.java<br>// Code snippet is from https://medium.com/@suman.maity112/reduce-build-time-by-running-tests-in-parallel-ec0d26f068a6<br><br>package com.suman;<br><br>import java.util.Arrays;<br>import java.util.stream.Stream;<br>import org.springframework.test.context.support.DefaultActiveProfilesResolver;<br>import org.apache.commons.lang3.RandomStringUtils;<br><br>public class CustomActiveProfilesResolver extends DefaultActiveProfilesResolver {<br>  @Override<br>  public String[] resolve(Class&lt;?&gt; testClass) {<br>    return Stream.concat(<br>            Stream.of(RandomStringUtils.randomAlphabetic(5).toLowerCase()),<br>            Arrays.stream(super.resolve(testClass)))<br>        .toArray(String[]::new);<br>  }<br>}</pre><pre>// ConfigRandomizer.java<br><br>package com.suman;<br><br>import lombok.extern.slf4j.Slf4j;<br>import org.springframework.boot.test.util.TestPropertyValues;<br>import org.springframework.context.ApplicationContextInitializer;<br>import org.springframework.context.ConfigurableApplicationContext;<br>import org.springframework.core.env.ConfigurableEnvironment;<br>import org.testcontainers.shaded.org.apache.commons.lang3.RandomStringUtils;<br><br>import java.util.AbstractMap;<br>import java.util.List;<br>import java.util.Map;<br>import java.util.stream.Collectors;<br><br>@Slf4j<br>public class ConfigRandomizer<br>    implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; {<br>  private static final List&lt;String&gt; CONFIG_TO_BE_RANDOMIZED =<br>      List.of(&quot;app.config.random.prefix&quot;);<br><br>  @Override<br>  public void initialize(ConfigurableApplicationContext applicationContext) {<br>    final ConfigurableEnvironment environment = applicationContext.getEnvironment();<br>    final String prefix = RandomStringUtils.randomAlphabetic(5).toLowerCase();<br><br>    log.info(&quot;===================== Using {} as prefix&quot;, prefix);<br><br>    final Map&lt;String, String&gt; updateConfig =<br>        CONFIG_TO_BE_RANDOMIZED.stream()<br>            .map(<br>                propertyName -&gt;<br>                    new AbstractMap.SimpleImmutableEntry&lt;&gt;(<br>                        propertyName,  &quot;%s_%s&quot;.formatted(prefix, environment.getProperty(propertyName, &quot;&quot;))))<br>            .collect(<br>                Collectors.toMap(<br>                    AbstractMap.SimpleImmutableEntry::getKey,<br>                    AbstractMap.SimpleImmutableEntry::getValue));<br><br>    TestPropertyValues.of(updateConfig).applyTo(applicationContext.getEnvironment());<br>  }<br>}</pre><pre>// HelloWorldIntegrationTest.java<br><br>package com.suman.hello;<br><br>import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;<br><br>import org.junit.jupiter.api.Test;<br>import org.springframework.boot.test.context.SpringBootTest;<br>import org.springframework.test.annotation.DirtiesContext;<br>import org.springframework.test.context.ActiveProfiles;<br>import org.springframework.test.context.ContextConfiguration;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper;<br>import com.suman.CustomActiveProfilesResolver;<br>import com.suman.ConfigRandomizer;<br>import com.suman.config.LocalDynamoConfig;<br><br>@DirtiesContext<br>@ActiveProfiles(value = &quot;test&quot;, resolver = CustomActiveProfilesResolver.class)<br>@ContextConfiguration(initializers = ConfigRandomizer.class)<br>@SpringBootTest(webEnvironment = RANDOM_PORT, classes = {LocalDynamoConfig.class})<br>class HelloWorldIntegrationTest {<br>  @Autowired private DynamoDBMapper dynamoDBMapper;<br><br>  @BeforeEach<br>  void setUp() {<br>    // ... create resources if needed<br>  }<br><br>  @AfterEach<br>  void cleanUp() {<br>    // ... cleanup resources if needed<br>  }<br><br>  @Test<br>  void shouldAbc(){<br>    // ...<br>  }<br><br>  @Test<br>  void shouldAbcd(){<br>    // ...<br>  }<br>}</pre><blockquote>Every other code snippet, excluding LocalDynamoConfig, was borrowed from the <a href="https://medium.com/@suman.maity112/reduce-build-time-by-running-tests-in-parallel-ec0d26f068a6">preceding blog</a>.</blockquote><p>These are the settings/tweaks required to utilize DynamoDBMapper and run parallel integration tests without altering any source code.</p><p>I hope these pointers would clarify how to set up DynamoDBMapper for parallel integration tests. Feel free to provide your feedback and opinions 😄.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=ad31e654047e" width="1" height="1" alt="">
