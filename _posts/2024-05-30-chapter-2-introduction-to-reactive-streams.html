---
layout: post
title: 'Chapter 2: Introduction to Reactive Streams'
canonical_url: https://medium.com/@suman.maity112/chapter-2-introduction-to-reactive-streams-3c730d89bc1f?source=rss-92eeb3145de9------2
tag:
- spring-reactive
- java
- software-development
- reactive-streams
- reactive-programming
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/745/1*2C1nuA0kSA5OX6BDuvdjTg.png" /></figure><p>In the <a href="https://medium.com/@suman.maity112/chapter-1-introduction-to-reactive-programming-e7aa6a4a4ace">previous chapter</a> we understood what is reactive programming and it’s characteristic. Before we proceed further, let’s try to understand one of the main concept/foundation behind reactive programming, which is Reactive Streams.</p><h3>Reactive Streams</h3><p>Reactive Streams is a specification for reactive programming created jointly by multiple organisation. These specifications are as follows —</p><h4>Publisher</h4><p>A Publisher is a provider of a potentially unbounded number of sequenced messages, publishing them according to the demand received from its Subscriber(s). Additionally a Publisher can serve multiple Subscriber(s) dynamically at various points in time.</p><p>The Publisher interface looks like as follows —</p><pre>public interface Publisher&lt;T&gt; {<br>  public void subscribe(Subscriber&lt;? super T&gt; s);<br>}</pre><p>With the help of subscribe(Subscriber&lt;? super T&gt; s) method, we can request the Publisher to start streaming data to it’s Subscriber(s).</p><p>In real world, the Publisher represents Database, remote service or other data sources.</p><h4>Subscriber</h4><p>The consumer/receiver of the messages needs to implement Subscriber interface. Typically this is the end for every <em>Flow </em>processing because the instance of it does not send messages further.</p><p>The Subscriber interface looks like as follows —</p><pre>public interface Subscriber&lt;T&gt; {<br>  public void onSubscribe(Subscription s);<br><br>  public void onNext(T t);<br><br>  public void onError(Throwable t);<br><br>  public void onComplete();<br>}</pre><p>onSubscribe(Subscription s) is called before data processing. The passed argument of Subscription instance is used to control the flow of data between Publisher and Subscriber.</p><p>onNext(T t) is invoked by the Publisher in order to transfer the data to Subscriber. This method is keep getting invoked until Subscription stops requesting for new data or there are no more data available in the data source (Publisher).</p><p>onComplete() is invoked by the Publisher to notify that there are no more data available.</p><p>onError(Throwable T) is invoked when something goes wrong. Once onError method is invoked, no more further data will sent even if there are new requests from Subscription.</p><h4>Subscription</h4><p>A Subscription represents a one-to-one lifecycle of a Subscriber subscribing to a Publisher. It can only be used once by a single Subscriber. The Subscription is use <em>demanded data</em> or cancel demand (which allows to cleanup the resources) from Publisher.</p><p>The Subscription interface looks like as follows —</p><pre>public interface Subscription {<br>  public void request(long n);<br><br>  public void cancel();<br>}</pre><p>request(long n) method in used to demand n numbers of data from the Publisher. No data will be transferred from Publisher until demand is signalled.</p><p>cancel() method is used to request the publisher to stop sending further data and cleanup the resources. Some data may still be sent to fulfil the demand from previous request.</p><h4>Processor</h4><p>A Processor represents processing stage, which has characteristic of both Subscriber and Publisher. This specification is not really used in day to day basis.</p><p>The Processor interface looks like as follows —</p><pre>public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; {}</pre><h3>Conclusion</h3><p>In summary, Reactive Streams revolutionise application development, offering resilience, responsiveness, and scalability. Standardizing asynchronous data handling, they empower real-time event response. Embracing these principles is pivotal for staying ahead in software development’s dynamic landscape.</p><blockquote>This article is a segment of the <strong><em>Cooking up Reactivity: The Spring Way </em></strong>series. To explore the entire series, <a href="https://medium.com/@suman.maity112/list/cooking-up-reactivity-the-spring-way-0f5795367dfa">click here</a>.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=3c730d89bc1f" width="1" height="1" alt="">
