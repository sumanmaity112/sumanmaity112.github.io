---
layout: post
title: 'Chapter 4: Building Blocks of Spring Reactive'
canonical_url: https://medium.com/@suman.maity112/chapter-4-building-blocks-of-spring-reactive-86b6bf13a109?source=rss-92eeb3145de9------2
tag:
- reactive-programming
- software-development
- java
- spring-webflux
- spring-reactive
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*Xf95QBIgggmEn2yczrJrJA.png" /><figcaption>The image was generated using <a href="https://gemini.google.com/">https://gemini.google.com/</a></figcaption></figure><p>The core components of Spring Reactive primarily include the following building blocks —</p><h4>Mono</h4><p>Mono is a Reactive Stream Publisher which can emits maximum 1 element via onNext signal or only emits a single onError signal.</p><h4>Flux</h4><p>Flux is also a Reactive Stream Publisher similar to Mono but it can emits multiple elements via onNext signal and then completes with either success or error signal.</p><h3>Mono</h3><p>As previously mentioned Mono can emit maximum 1 element. It can be used when we know the underlaying publisher will publish maximum 1 element or an error signal.</p><h4>How can we create a new Mono</h4><p>Mono can be created in multiple ways, here are the couple of ways to do the same —</p><ul><li>Mono.empty() — When you just want to create empty Mono publisher, Mono.empty() can be used.</li><li>Mono.just(&lt;element&gt;) — When you already know the element, an instance of Mono can be easily created by using Mono.just(&lt;element&gt;). <strong><em>For example</em></strong></li></ul><pre>Mono.just(5); // Will create a Mono which emit 5 as next element</pre><ul><li>Mono.justOrEmpty() — When you have a <em>nullable</em> value, Mono.justOrEmpty() can be used to create a Mono. Based on input it’ll either provide a empty Mono similar to Mono.empty() or Mono with 1 element similar to Mono.just(&lt;element&gt;). You can also provide Optional value as an input to Mono.justOrEmpty(&lt;Optional&gt;). <strong><em>For example</em></strong></li></ul><pre>Mono.justOrEmpty(5); // Will create a Mono which emit 5 as next element<br>Mono.justOrEmpty(Optional.of(5)); // Will create a Mono which emit 5 as next element<br><br>Mono.justOrEmpty(null); // Will create a empty Mono<br>Mono.justOrEmpty(Optional.empty()); // Will create a empty Mono</pre><ul><li>Mono.fromCallable(&lt;runnable&gt;) — When the element is not directly available and need to invoke some sort of <em>synchronous/blocking </em>method to produce the value Mono.fromCallable(&lt;runnable&gt;) can be used. Incase provided Runnable returns null value, then it’ll create an empty Mono. <strong><em>For example</em></strong></li></ul><pre>Mono.fromCallable(() -&gt; 5); // Will create a Mono which emit 5 as next element<br>Mono.fromCallable(() -&gt; null); // Will create a empty Mono<br>Mono.fromCallable(() -&gt;<br> new RuntimeException(&quot;Just a demo error scenario&quot;)); // will create a Mono which emits error signal</pre><ul><li>Mono.defer(&lt;supplier&gt;) — This method is also similar to Mono.fromCallable(&lt;runnable&gt;) but in this case the provided supplier already returns a Mono. This is particularly useful to create a completely new Mono stream from one of the existing stream. <strong><em>For example</em></strong></li></ul><pre>Mono.defer(() -&gt; Mono.just(5)); // Will create a Mono which emit 5 as next element</pre><ul><li>Mono.error(&lt;throwable/throwable supplier&gt;) — When there is a need to create Mono which emits <em>error</em> signal instead of a <em>success</em><strong> </strong>Mono.error(&lt;throwable/throwable supplier&gt;) can be used. <strong><em>For example</em></strong></li></ul><pre>Mono.error(new RuntimeException(&quot;Just a demo error scenario&quot;));<br>Mono.error(() -&gt; new RuntimeException(&quot;Just a demo error scenario&quot;));</pre><p>There are many other ways of creating a Mono, but here I just added most of common ways to create a new Mono, more information can be found on <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Spring documentation</a>.</p><h3>Flux</h3><p>Flux is used as publisher to emit 0 to N elements. Flux may produce multiple error signal based on our use-case (we’ll discuss this in later part) but generally it stops when the first error signal emits.</p><h4>How can we create a new Flux</h4><p>Flux can be created in multiple ways, here are couple of ways to do the same —</p><ul><li>Flux.empty() — When you just want to create empty Flux publisher, Flux.empty() can be used.</li><li>Flux.just(&lt;elements&gt;) — When you already know the elements, an instance of Mono can be easily created by using Flux.just(&lt;elements&gt;). <strong><em>For example</em></strong></li></ul><pre>Flux.just(5); // Will create a Flux which emit 5 as next element<br>Flux.just(5, 9, 0, 6, 4); // Will a Flux which will emits the elements in order as 5, 9, 0, 6 and 4</pre><ul><li>Flux.fromIterable(&lt;iterable&gt;) — When the elements are already part of some sort of Iterable like, List, Set etc, Flux.fromIterable(&lt;iterable&gt;) can be used to convert Iterable to a Flux publisher. <strong><em>For example</em></strong></li></ul><pre>Flux.fromIterable(List.of(1, 2, 3));<br>Flux.fromIterable(Set.of(1, 2, 3));</pre><ul><li>Flux.fromStream(&lt;stream/stream supplier&gt;) — When the elements are part of Stream or the elements will be provided as Stream once some method is invoked, then Flux.fromStream(&lt;stream/stream supplier&gt;) can be used to create a Flux publisher from the Stream. <strong><em>For example</em></strong></li></ul><pre>Flux.fromStream(Stream.of(1, 2, 3));<br>Flux.fromStream(() -&gt; Stream.of(1, 2, 3));</pre><ul><li>Flux.defer(&lt;supplier&gt;) — When there is a need to create a new Flux from an existing one, we can use Flux.defer(&lt;supplier&gt;). <strong><em>For example</em></strong></li></ul><pre>Flux.defer(() -&gt; Flux.just(1, 2, 3));</pre><ul><li>Flux.error(&lt;throwable/throwable supplier&gt;) — When there is a need to create Flux which emits <em>error</em> signal instead of a <em>success</em><strong> </strong>Flux.error(&lt;throwable/throwable supplier&gt;) can be used. <strong><em>For example</em></strong></li></ul><pre>Flux.error(new RuntimeException(&quot;Just a sample error scenario&quot;));<br>Flux.error(() -&gt; new RuntimeException(&quot;Just a sample error scenario&quot;));</pre><p>There are many other ways of creating a Flux, but here I just added most of common ways to create a new Flux, more information can be found on <a href="https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Spring documentation</a>.</p><h3>Conclusion</h3><p>In summary, Mono and Flux stand as pivotal elements within Spring Reactive, providing robust abstractions for managing asynchronous data streams. Mono handles single or optional results, while Flux caters to streams with 0 to N items. Mastery of these components equips developers to create responsive, resilient, and scalable applications, maximising the capabilities of Spring Reactive.</p><blockquote>This article is a segment of the <strong><em>Cooking up Reactivity: The Spring Way </em></strong>series. To explore the entire series, <a href="https://medium.com/@suman.maity112/list/cooking-up-reactivity-the-spring-way-0f5795367dfa">click here</a>.</blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=86b6bf13a109" width="1" height="1" alt="">
