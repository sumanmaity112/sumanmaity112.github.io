---
layout: post
title: Parameterized Tests with Java and Junit5
canonical_url: https://medium.com/@suman.maity112/parameterized-tests-with-java-and-junit5-c7822df5bc7a?source=rss-92eeb3145de9------2
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/707/1*0BGdehDO_EXsAffpoObzlA.jpeg" /></figure><p>In my <a href="https://medium.com/@suman.maity112/parameterized-tests-8929080901ee">other blog</a>, we understood what is a parameterized test. Now as part of this article, we‚Äôll try to understand how to do it using Java and Junit5. So let‚Äôs write some code and see how can we do¬†it.</p><p>To be able to write Parameterized tests with Java and Junit5, we have to add the following package to your dependencies -</p><pre><strong>Group ID</strong>: org.junit.jupiter<br><strong>Artifact ID:</strong> junit-jupiter-params<br><strong>Version:</strong> 5.5.2<br><strong>Scope:</strong> test</pre><p>Once we have added this dependency then we can start declaring a test method with parameters. We have to use @ParameterizedTest<strong> </strong>annotation instead of¬†@Test.</p><pre>@ParameterizedTest<br>void parameterizedTest(String input) {<br>    <em>assertNotNull</em>(input);<br>}</pre><p>Is that it? ü§î No, something is missing here‚Ää‚Äî‚Ääfrom where the parameter <strong><em>input</em></strong><em> </em>is¬†coming?</p><p>So, to run this test we have to provide the argument to it. To provide the arguments to parametrized tests there are various sources. The easiest one is @ValueSource</p><pre>@ParameterizedTest<br>@ValueSource(strings = { &quot;example&quot;, &quot;parameter&quot; })<br>void parameterizedTest(String input) {<br>    <em>assertNotNull</em>(input);<br>}</pre><p>Now it‚Äôs complete and it will run for ‚Äú<em>example</em>‚Äù and ‚Äú<em>parameter</em>‚Äù as¬†input.</p><p>This way, we can write tests for as many arguments as we¬†want.</p><h3>Argument Sources</h3><p>As I already told there are various types of argument source we can use while providing the arguments to a test method, let‚Äôs have a look into¬†those:</p><p><strong><em>Value Source</em></strong></p><p>We have already seen @ValueSource in action. It‚Äôs very simple to use and type-safe for few basic java types. To use this we just have to add annotation and then pick only one from the following elements:</p><ul><li><strong>String</strong>[] strings()</li><li><strong>int</strong>[] ints()</li><li><strong>long</strong>[] longs()</li><li><strong>double</strong>[] doubles()</li></ul><p>In the previous example, we show strings<strong><em> </em></strong>into action. Let‚Äôs check another example for¬†ints<em>:</em></p><pre>@ParameterizedTest<br>@ValueSource(ints = { 1, 2 })<br>void parameterizedTest(int input) {<br>    <em>assertNotNull</em>(input);<br>}</pre><p>This source has mainly two disadvantages:</p><ul><li>It can only be used on a test method which requires only one argument as¬†input</li><li>It supports only basic Java types, we can‚Äôt use it to provide arbitrary objects</li></ul><p>So for most complex test methods, we have to use one of the other¬†sources.</p><p><strong>Enum Source</strong></p><p>This source is used to run a test once for each value or subset of an¬†enum.</p><pre>@ParameterizedTest<br>@EnumSource(value = TimeUnit.class)<br>void withAllTimeUnit(TimeUnit timeUnit) {<br>    // It&#39;ll run for each time unit<br>}</pre><pre>@ParameterizedTest<br>@EnumSource(value = TimeUnit.class, names = {&quot;SECONDS&quot;, &quot;MINUTES&quot;})<br>void parameterizedTest(TimeUnit timeUnit) {<br>    /*<br>    It&#39;ll run for once for TimeUnit.SECONDS and<br>    and once for TimeUnit.MINUTES<br>    */<br>}</pre><p>Simple right? But note that @EnumSource create arguments for only one parameter i.e it could be only used for a test method requires only one argument as input. To take more detailed control over which enum values are provided, take a look into the <a href="https://junit.org/junit5/docs/current/api/org/junit/jupiter/params/provider/EnumSource.html#mode()"><em>mode</em> attribute</a>.</p><p><strong>Method Source</strong></p><p>@ValueSource and @EnumSource are simple and somewhat limited - on the other hand, @MethodSource is generic. It simply method‚Äôs name that will be called to provide a stream of arguments. Let‚Äôs check the following example:</p><pre>private static Stream&lt;Arguments&gt; getArgumentsForIsPalindrome() {<br>    return Stream.<em>of</em>(<br>            Arguments.<em>of</em>(&quot;racecar&quot;, true),<br>            Arguments.<em>of</em>(&quot;car&quot;, false)<br>    );<br>}</pre><pre>@ParameterizedTest(name = &quot;expected result \&quot;{1}\&quot; for given text \&quot;{0}\&quot;&quot;)<br>@MethodSource(&quot;getArgumentsForIsPalindrome&quot;)<br>@DisplayName(&quot;Tests for isPalindrome&quot;)<br>void validateIsPalindrome(String text, boolean expected) {<br>    <em>assertEquals</em>(expected, <em>isPalindrome</em>(text));<br>}</pre><p>Arguments is a simple interface wrapping an array of objects and Arguments.of(Object‚Ä¶ args creates an instance of it from the specified args. The class backing up the @MethodSource annotation takes care of the rest and our test method validateIsPalindrome executes twice: once with the argument racecar and true and once with car and false¬†.</p><p>If this source is used for a single argument, then we don‚Äôt have to wrap the argument into Argument.of(Object... args)¬†.</p><pre>private static Stream&lt;Integer&gt; getInts() {<br>    return Stream.<em>of</em>(1, 2, 3);<br>}</pre><pre>@ParameterizedTest<br>@MethodSource(&quot;getInts&quot;)<br>void parameterizedTest(int input) {<br>    System.<em>out</em>.println(input);<br>}</pre><p>The method called by @MethodSource should return a collection which can be any kind of <em>Stream, Iterable, Iterator</em> or <em>Array</em>. Also, this method should be <em>Static</em>, can be private and doesn‚Äôt have to be in the same¬†class.</p><blockquote>If no name is given to @MethodSource, it will look for an arguments-providing method with the same name as the test¬†method.</blockquote><p>As we saw @MethodSource is a very generic argument source but it has the overhead of declaring a method and putting down all the arguments together.</p><p><strong>CSV Source</strong></p><p>How about a way to define a handful of arguments without defining a method like @MethodSource¬†? Let‚Äôs say hello to @CsvSource¬†, using this annotation we can declare our arguments as a list of comma-separated value. Let‚Äôs check the following example:</p><pre>@ParameterizedTest(name = &quot;expected result \&quot;{1}\&quot; for given text \&quot;{0}\&quot;&quot;)<br>@CsvSource(value = {&quot;racecar, true&quot;, &quot;car, false&quot;})<br>@DisplayName(&quot;Tests for isPalindrome&quot;)<br>void validateIsPalindrome(String text, boolean expected) {<br>    <em>assertEquals</em>(expected, <em>isPalindrome</em>(text));<br>}</pre><p>In this example, the source is defined for two groups of arguments, leading two method execution.</p><p>To define delimiter explicitly, we can use the delimeter attribute.</p><p><strong>CSV File¬†Source</strong></p><p>@CsvSource is nice but what if I have large amounts of CSV inputs and it stored in a file, what to do now? ü§î In such scenarios, our other friend @CsvFileSource comes¬†in.</p><pre>@ParameterizedTest(name = &quot;expected result \&quot;{1}\&quot; for given text \&quot;{0}\&quot;&quot;)<br>@CsvFileSource(resources = &quot;/input.csv&quot;)<br>@DisplayName(&quot;Tests for isPalindrome&quot;)<br>void validateIsPalindrome(String text, boolean expected) {<br>    <em>assertEquals</em>(expected, <em>isPalindrome</em>(text));<br>}</pre><p>In this example @CsvFileSource will read <em>input.csv</em> file from resources directory and provide argument one after another. By using <a href="https://junit.org/junit5/docs/current/api/org/junit/jupiter/params/provider/CsvFileSource.html">other attributes</a> we can specify the <em>file‚Äôs encoding</em>, <em>line separator</em> and <em>delimiter</em>.</p><p><em>Note: </em><em>resources can accept multiple file name and process one after¬†another.</em></p><p><strong>Custom Argument¬†Sources</strong></p><p>Above we look into the in-built argument sources which serve most of the use cases but in case these requirements are unable to fulfil your requirements, you can easily create one. To create our own source, we have to implement org.junit.jupiter.params.provider.ArgumentsProvider interface with a class having default constructor. Once you are done with implementing it, you can use it @ArgumentSource(MyCustomSource.class)¬†.</p><blockquote><em>Tip: You can create a custom annotation for </em><em>@ArgumentSource(MyCustomSource.class)</em></blockquote><h3>Conclusion</h3><p>I hope you‚Äôve been able to understand how to write parameterized tests in Java with¬†Junit5.</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=c7822df5bc7a" width="1" height="1" alt="">
