---
layout: post
title: How to reduce JVM docker image size by at least 60%
canonical_url: https://medium.com/@suman.maity112/how-to-reduce-jvm-docker-image-size-by-at-least-60-459ec87b95d8?source=rss-92eeb3145de9------2
tag:
- java
- custom-jre
- image-size-reduce
- jvm
- docker
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*cR9eGZr50HArf_j9-rnjjQ.png" /></figure><p>If you’ve been working with JVM-based languages (Java, Kotlin, Scala, and so on) for a while, you may have noticed that, beginning with Java 11, the Java Runtime Environment (JRE) no longer has a separate distribution. Because of this decision, many Java Development Kit (JDK) docker image distributors, such as <a href="https://hub.docker.com/_/openjdk">OpenJDK</a>, <a href="https://hub.docker.com/_/amazoncorretto">Amazon Correto</a>, and others, do not provide JRE as a separate docker image. Using these images resulted in an overall Docker image size of about 360 MB, while the actual application jar size was about 26 MB. The overall Docker image size is too large in my opinion, and it should be reduced in order to save space and network bandwidth for everyone who will use this Docker image. Now, let’s see how to drastically reduce the Docker image size.</p><h3>The root of this problem</h3><p>The <a href="https://www.oracle.com/corporate/features/understanding-java-9-modules.html">Java Platform Module System (JPMS)</a> was introduced with <a href="https://www.oracle.com/java/technologies/javase/9-all-relnotes.html">Java 9</a>. We can use JPMS to create our own custom JRE that is suitable for specific applications. For example, if an application does not use audio, image, or JavaBeans-related features, we can remove the java.desktop module entirely to free up space in our Docker image.</p><p>As previously stated, there is no separate JRE distribution from <a href="https://www.oracle.com/java/technologies/javase/11-relnote-issues.html">Java 11</a> onwards. That means that even if we just want to run a simple JVM-based application, we must install the entire JDK. This is due to the modularity introduced in Java 9. The main philosophy is that instead of providing a generic JRE that meets everyone’s needs, everyone should be able to create their own JRE. Many JDK image providers follow the same philosophy by omitting JRE distributions.</p><p>Unfortunately, using such images significantly increases the size of the Docker image.</p><p>To better understand this issue, let’s look at the basic Dockerfile required to run a simple JVM-based application.</p><pre># greetings.Dockerfile<br><br>FROM amazoncorretto:17-alpine<br>EXPOSE 8080<br>COPY ./greetings/build/libs/greetings.jar /app/<br>WORKDIR /app<br><br>CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;greetings.jar&quot;]</pre><p>We’re using amazoncorretto:17-alpine as the base image here, and we’re copying the application jar file to it. At the end we run the jar file.</p><p>Let’s run this Dockerfile and see how big it is.</p><pre>ls -lh greetings/build/libs/greetings.jar | awk &#39;{print $5, $9}&#39;<br># 26M greetings/build/libs/greetings.jar<br><br>docker build -t greetings:jdk -f greetings.Dockerfile .<br><br>docker image ls | grep greetings<br><br># The output looks like following<br># greetings    jdk     ca39786a6f62   2 hours ago      361MB</pre><p>That is, the image size of 361 MB is quite large for a jar file of 26 MB, isn’t it? So, how can we make it smaller?</p><h3>The Solution</h3><p>Along with modularity, Java 9 includes a tool called <a href="https://docs.oracle.com/javase/9/tools/jlink.htm">jlink</a>. The main purpose of this tool is to assist us in creating custom JRE based on our needs. This tool offers a few options for fine-tuning JRE and the required modules, but it also offers the option of creating a generic JRE that includes all of the modules.</p><h4>Custom JRE</h4><p>Let’s start with a look at the generic Docker image.</p><pre># greetings.Dockerfile<br><br>FROM amazoncorretto:17-alpine as corretto-jdk<br><br># required for strip-debug to work<br>RUN apk add --no-cache binutils<br><br># Build small JRE image<br>RUN jlink \<br>         --add-modules ALL-MODULE-PATH \<br>         --strip-debug \<br>         --no-man-pages \<br>         --no-header-files \<br>         --compress=2 \<br>         --output /jre<br><br>FROM alpine:latest<br>ENV JAVA_HOME=/jre<br>ENV PATH=&quot;${JAVA_HOME}/bin:${PATH}&quot;<br><br>COPY --from=corretto-jdk /jre $JAVA_HOME<br><br>EXPOSE 8080<br>COPY ./greetings/build/libs/greetings.jar /app/<br>WORKDIR /app<br><br>CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;greetings.jar&quot;]</pre><p>Let’s go over this file quickly.</p><ul><li>In this case, we used Docker multi-staged builds.</li><li>We use the same amazoncorretto:17-alpine Docker image as the base image in the first stage.</li><li>Following that, we install binutils, which is required by the jlink tool. The jlink tool is then used to create a custom JRE. The most important part of this command is --add-modules ALL-MODULE-PATH, which adds all the modules to JRE. On the <a href="https://docs.oracle.com/javase/9/tools/jlink.htm">Oracle documentation page</a>, you can learn more about all of the options.</li><li>The alpine:latest image is used as the base image in the second stage.</li><li>Then we copy the newly created custom JRE from the previous stage.</li><li>Finally, we are running our application jar file.</li></ul><p>Let’s now build this new dockerfile and examine the image size.</p><pre>docker build -t greetings:jre -f greetings.Dockerfile .<br><br>docker image ls | grep greetings<br><br># The output looks like following<br># greetings    jre    d5f20dab834c   2 hours ago      123MB</pre><p>That is the new image size is only 123 MB, which is nearly a third of the original image size, and this includes all modules.</p><p>Can we further reduce the size by only including the modules that are required? Yes, but the main question is how to determine which modules are required for the application to function properly.</p><h4>Slim JRE</h4><p>We can use the <a href="https://docs.oracle.com/javase/9/tools/jdeps.htm#JSWOR690">jdeps</a> command to determine the necessary modules. jdeps was first introduced in <a href="https://www.oracle.com/java/technologies/javase/8all-relnotes.html">Java 8</a> to examine dependencies in an application. Additionally, jdeps can discover every Java module that every library dependency uses. Before running the jdeps command, we must extract the jar file in order for it to function properly.</p><pre>unzip ./greetings/build/libs/greetings.jar -d temp<br><br>jdeps \<br>  --print-module-deps \<br>  --ignore-missing-deps \<br>  --recursive \<br>  --multi-release 17 \<br>  --class-path=&quot;./temp/BOOT-INF/lib/*&quot; \<br>  --module-path=&quot;./temp/BOOT-INF/lib/*&quot; \<br>  ./greetings/build/libs/greetings.jar<br><br># The output will look like following<br># java.base,java.compiler,java.desktop,java.instrument,java.management,java.naming,java.prefs,java.rmi,java.scripting,java.security.jgss,java.sql,jdk.httpserver,jdk.jfr,jdk.unsupported<br><br>rm -rf temp</pre><p>As you can see, we first extract the application jar file to a temporary directory before running the jdeps command with few <a href="https://docs.oracle.com/javase/9/tools/jdeps.htm">configuration options</a>. Finally, we remove the temporary directory.</p><blockquote>Note: jdeps will not be able to print required modules used by Reflection. For example, if application contains spring security, we need to add jdk.crypto.ec and jdk.crypto.cryptoki module manually.</blockquote><p>Now we’ll replace ALL-MODULE-PATH with the list printed by jdeps.</p><pre># greetings.Dockerfile<br><br>FROM amazoncorretto:17-alpine as corretto-jdk<br><br># required for strip-debug to work<br>RUN apk add --no-cache binutils<br><br># Build small JRE image<br>RUN jlink \<br>         --verbose \<br>         --add-modules java.base,java.compiler,java.desktop,java.instrument,java.management,java.naming,java.prefs,java.rmi,java.scripting,java.security.jgss,java.sql,jdk.httpserver,jdk.jfr,jdk.unsupported,jdk.crypto.ec,jdk.crypto.cryptoki \<br>         --strip-debug \<br>         --no-man-pages \<br>         --no-header-files \<br>         --compress=2 \<br>         --output /jre<br><br>FROM alpine:latest<br>ENV JAVA_HOME=/jre<br>ENV PATH=&quot;${JAVA_HOME}/bin:${PATH}&quot;<br><br>COPY --from=corretto-jdk /jre $JAVA_HOME<br><br>EXPOSE 8080<br>COPY ./greetings/build/libs/greetings.jar /app/<br>WORKDIR /app<br><br>CMD [&quot;java&quot;, &quot;-jar&quot;, &quot;greetings.jar&quot;]<br></pre><p>Let’s now build this new dockerfile and examine the image size.</p><pre>docker build -t greetings:slimjre -f greetings.Dockerfile .<br><br>docker image ls | grep greetings<br><br># The output looks like following<br># greetings    slimjre    450a64815cb3   46 minutes ago   89.8MB</pre><p>That is the new image size is only 90 MB, which is nearly a quarter of the original image size. Isn’t that preferable?</p><h4>Problem with Slim JRE and how to fix it</h4><p>We knew from previous results that slim JRE is superior to generic JRE. However, the slim JRE has a minor flaw. If the application is still in development, we may need to make frequent changes to our Dockerfile. Also, because we are changing the Dockerfile, Docker may not be able to reuse all of the layers.</p><h4>Automated Slim JRE</h4><p>If you continue to rely on using the slim JRE, we can at least automate the above process to make our lives a little easier. To automate the process, see the following GitHub gist:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f85efed2e5e0c531efcabc0570c24623/href">https://medium.com/media/f85efed2e5e0c531efcabc0570c24623/href</a></iframe><h3>Final Thoughts</h3><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*pKdmS4ej4EwFa4qGEwhVFA.png" /><figcaption>image size comparison</figcaption></figure><p>As you can see, we were able to reduce the image size by nearly three times with minimal effort. We have two alternatives.</p><ul><li>Slim JRE, the image size is extremely small, and it contains only the required Java module, which may necessitate frequent updates to the dockerfile, and Docker may be unable to reuse layers across projects.</li><li>Generic JRE, the image size of the generic JRE is slightly larger than that of the slim JRE, but it contains all of the Java modules.</li></ul><p>It is up to you to determine which JRE is best suited for your application. However, with either option, you will be able to drastically reduce the image size.</p><p><em>Note: Slim JRE concepts is getting used in </em><a href="https://github.com/otto-de/gitactionboard"><em>gitactionboard</em></a><em>, you can find the size difference on </em><a href="https://hub.docker.com/r/ottoopensource/gitactionboard/tags"><em>docker page</em></a><em>.</em></p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=459ec87b95d8" width="1" height="1" alt="">
<p>Originally posted on <a href="https://medium.com/@suman.maity112/how-to-reduce-jvm-docker-image-size-by-at-least-60-459ec87b95d8?source=rss-92eeb3145de9------2">medium.com</a>.</p>
