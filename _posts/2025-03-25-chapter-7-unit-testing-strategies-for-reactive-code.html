---
layout: post
title: 'Chapter 7: Unit Testing Strategies for Reactive Code'
canonical_url: https://medium.com/@suman.maity112/chapter-7-unit-testing-strategies-for-reactive-code-fc23f57337b9?source=rss-92eeb3145de9------2
tag:
- spring-webflux
- unit-testing
- software-development
- java
- reactive-programming
---

<figure><img alt="" src="https://cdn-images-1.medium.com/max/578/1*GSUx3v93FsAq7k-vnxNoig.png" /></figure><p>Unit testing is a fundamental aspect of software development, ensuring the reliability, correctness, and maintainability of our applications. In the realm of <a href="https://spring.io/reactive">Spring Reactive</a>, where asynchronous and event-driven programming paradigms prevail, testing takes on a unique significance. In this chapter, we’ll explore comprehensive testing practices for Spring Reactive applications, covering mainly unit tests but similar testing strategies can be utilised for other types of tests like integration and end-to-end tests.</p><h3>Challenges of Unit Testing in Spring Reactive</h3><p>Unit testing in Spring Reactive presents several challenges, primarily due to the asynchronous and event-driven nature of reactive programming. Traditional testing approaches may not suffice when dealing with reactive components such as Flux and Mono. Asynchronous execution introduces complexities such as timing issues, thread safety concerns, and the need for handling reactive streams effectively.</p><h3>Best Practices for Unit Testing Spring Reactive</h3><ul><li><strong>Embrace Reactive Testing Libraries</strong>: Leverage libraries such as <a href="https://projectreactor.io/">Project Reactor</a>’s <a href="https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html">StepVerifier</a> or AssertJ’s reactive/asynchronous assertions to test reactive components effectively. These libraries provide utilities for composing and verifying reactive sequences, simplifying the testing process.</li><li><strong>Mocking and Stubbing</strong>: Utilize mocking frameworks like <a href="https://site.mockito.org/">Mockito</a> to mock external dependencies and stub reactive data sources. Mocking enables isolation of the unit under test, ensuring focused and deterministic tests.</li><li><strong>Test with Virtual Time</strong>: Spring provides support for virtual time in tests, allowing control over the progression of time within a test context. This is particularly useful for testing time-sensitive operations in reactive code, ensuring predictable and reproducible outcomes.</li><li><strong>Use Virtual Schedulers</strong>: Project Reactor offers <a href="https://projectreactor.io/docs/test/release/api/reactor/test/scheduler/VirtualTimeScheduler.html">VirtualTimeScheduler</a> for controlling the execution of reactive code in tests. By using <a href="https://projectreactor.io/docs/test/release/api/reactor/test/scheduler/VirtualTimeScheduler.html">VirtualTimeScheduler</a>, you can simulate different execution contexts, such as parallelism and concurrency, enabling comprehensive testing of reactive scenarios.</li><li><strong>Test Error Handling and Backpressure</strong>: Reactive applications must handle errors and backpressure gracefully to maintain stability and resilience. Write tests to validate error-handling mechanisms and backpressure strategies, ensuring robustness under varying conditions.</li></ul><p>Here we will focus on Project Reactor’s <a href="https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html">StepVerifier</a> for unit testing.</p><h3>Getting Started</h3><p>To start with Project Reactor’s <a href="https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html">StepVerifier</a>, the following dependency should be incorporated into the dependency management file, such as build.gradle or pom.xml:</p><pre>&lt;!-- https://mvnrepository.com/artifact/io.projectreactor/reactor-test --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;<br>    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;<br>    &lt;version&gt;${version}&lt;/version&gt;<br>    &lt;scope&gt;test&lt;/scope&gt;<br>&lt;/dependency&gt;</pre><h3>Understanding StepVerifier</h3><p>StepVerifier is a testing utility provided by Project Reactor, designed specifically for testing reactive code. It allows developers to assert and verify the behavior of reactive streams in a concise and expressive manner. StepVerifier operates by subscribing to a Flux or Mono sequence and then asserting the emitted elements, terminal events, and errors.</p><h3>StepVerifier Operators</h3><h4>create</h4><p>StepVerifier.create() is used to transform a reactive publisher to StepVerifier which can be utilize for assertions.</p><p><strong>Syntax:</strong></p><pre>static &lt;T&gt; FirstStep&lt;T&gt; create(Publisher&lt;? extends T&gt; publisher)<br><br>static &lt;T&gt; FirstStep&lt;T&gt; create(Publisher&lt;? extends T&gt; publisher, long n)<br><br>static &lt;T&gt; FirstStep&lt;T&gt; create(Publisher&lt;? extends T&gt; publisher,<br>                               StepVerifierOptions options)</pre><p><strong>Example:</strong></p><pre>// Transform the Mono publisher to StepVerifier<br>StepVerifier.create(Mono.just(1));<br><br>// Transform the Flux publisher to StepVerifier<br>Flux.just(1, 2, 3).as(StepVerifier::create);<br><br>// Transform the Flux publisher to StepVerifier and initially request for<br>// 2 elements<br>StepVerifier.create(Flux.just(1, 2, 3), 2);<br><br>// Transform the Flux publisher to StepVerifier with &quot;Demo Scenario&quot; as<br>// scenario name and initially request for 2 elements<br>StepVerifier.create(<br>    Flux.just(1, 2, 3),<br>    StepVerifierOptions.create()<br>      .scenarioName(&quot;Demo Scenario&quot;)<br>      .initialRequest(2));</pre><h4>expectNext</h4><p>StepVerifier.expectNext() is the basic from of assertion where emitted elements can be asserted in ordered way.</p><p><strong>Syntax:</strong></p><pre>Step&lt;T&gt; expectNext(T... ts)</pre><p><strong>Example:</strong></p><pre>// Transform the Mono publisher to StepVerifier and expect next element as 1<br>StepVerifier.create(Mono.just(1))<br>    .expectNext(1);<br><br>// Transform the Flux publisher to StepVerifier and expect next elements are 1, 2, 3 in same sequence<br>Flux.just(1, 2, 3).as(StepVerifier::create)<br>    .expectNext(1, 2, 3);</pre><h4>expectComplete</h4><p>StepVerifier.expectComplete() is used to verify complete as terminal signal.</p><p><strong>Syntax:</strong></p><pre>StepVerifier expectComplete()</pre><p><strong>Example:</strong></p><pre>// Transform the Mono publisher to StepVerifier and expect next element as 1<br>StepVerifier.create(Mono.just(1))<br>    .expectNext(1)<br>    .expectComplete();<br><br>// Transform the Flux publisher to StepVerifier and expect next elements are 1, 2, 3 in same sequence<br>Flux.just(1, 2, 3).as(StepVerifier::create)<br>    .expectNext(1, 2, 3)<br>    .expectComplete();</pre><h4>verify</h4><p>StepVerifier.verify() is used to verify signals received by the subscriber. This method will <strong>block</strong> for maximum specified time or until the stream has been terminated (either through Subscriber. onComplete(), Subscriber. onError(Throwable) or Subscription. cancel()).</p><p><strong>Syntax:</strong></p><pre>Duration verify() throws AssertionError<br><br>Duration verify(Duration duration) throws AssertionError</pre><p><strong>Example:</strong></p><pre>// Transform the Mono publisher to StepVerifier and expect next element as 1<br>StepVerifier.create(Mono.just(1))<br>    .expectNext(1)<br>    .expectComplete()<br>    .verify();<br><br>// Transform the Flux publisher to StepVerifier and expect next elements are<br>// 1, 2, 3 in same sequence and wait for maximum 2 seconds<br>Flux.just(1, 2, 3).delayElements(Duration.ofSeconds(1)).as(StepVerifier::create)<br>    .expectNext(1, 2, 3)<br>    .expectComplete()<br>    .verify(Duration.ofSeconds(2)); // we&#39;ll receive timed out exception</pre><h4>verifyComplete</h4><p>StepVerifier.verifyComplete() is a syntactic sugar which internally expect complete terminal signal using expectComplete() and verifies the same using verify() with default timeout config.</p><p><strong>Syntax:</strong></p><pre>Duration verifyComplete();</pre><p><strong>Example:</strong></p><pre>// Transform the Mono publisher to StepVerifier and expect next element as 1<br>StepVerifier.create(Mono.just(1))<br>    .expectNext(1)<br>    .verifyComplete();<br><br>// Transform the Flux publisher to StepVerifier and expect next elements are<br>// 1, 2, 3 in same sequence<br>Flux.just(1, 2, 3).delayElements(Duration.ofSeconds(1)).as(StepVerifier::create)<br>    .expectNext(1, 2, 3)<br>    .verifyComplete();</pre><h4>assertNext</h4><p>StepVerifier.expectNext() is really great operator to perform verifications for primitives, simple objects but when it’s comes to verification for complex objects expectNext() isn’t capable to provide human readable simple error message. Here comes StepVerifier.assertNext() to rescue, where we can write complex readable assertions.</p><p><strong>Syntax:</strong></p><pre>Step&lt;T&gt; assertNext(Consumer&lt;? super T&gt; assertionConsumer)</pre><p><strong>Example:</strong></p><pre>Flux.just(new Person(1, &quot;John&quot;), new Person(2, &quot;Finnch&quot;), new Person(3, &quot;Chris&quot;))<br>    .as(StepVerifier::create)<br>    .assertNext(element -&gt; assertThat(element).isEqualTo(new Person(1, &quot;John&quot;)))<br>    .assertNext(element -&gt; assertThat(element).isEqualTo(new Person(2, &quot;Finnch&quot;)))<br>    .assertNext(element -&gt; assertThat(element).isEqualTo(new Person(3, &quot;Chris&quot;)))<br>    .verifyComplete();</pre><h4>expectNextCount</h4><p>In some special scenarios we may want to just verify the number of emitted elements instead of actual value for each and every elements, in those case StepVerifier.expectNextCount() comes handy.</p><p><strong>Syntax:</strong></p><pre>Step&lt;T&gt; expectNextCount(long count)</pre><p><strong>Example:</strong></p><pre>Flux.just(1, 2, 3)<br>    .as(StepVerifier::create)<br>    .expectNextCount(2)<br>    .expectNext(3)<br>    .verifyComplete();</pre><h4>expectError</h4><p>StepVerifier.expectError() is the opposite of expectComplete(), used to verify error as terminal signal.</p><p><strong>Syntax:</strong></p><pre>StepVerifier expectError()<br><br>StepVerifier expectError(Class&lt;? extends Throwable&gt; clazz)</pre><p><strong>Example:</strong></p><pre>// Transform the error Mono publisher to StepVerifier and expect it to<br>// terminate with error<br>Mono.error(new IllegalArgumentException(&quot;test error&quot;))<br>    .as(StepVerifier::create)<br>    .expectError()<br>    .verify();<br><br>// Transform the error Mono publisher to StepVerifier and expect it to<br>// terminate with IllegalArgumentException error<br>Mono.error(new IllegalArgumentException(&quot;test error&quot;))<br>    .as(StepVerifier::create)<br>    .expectError(IllegalArgumentException.class)<br>    .verify();</pre><h4>verifyError</h4><p>StepVerifier.verifyError() is also a syntactic sugar similar to verifyComplete() which internally expect error terminal signal using expectError() and verifies the same using verify() with default timeout config.</p><p><strong>Syntax:</strong></p><pre>StepVerifier verifyError()<br><br>StepVerifier verifyError(Class&lt;? extends Throwable&gt; clazz)</pre><p><strong>Example:</strong></p><pre>// Transform the error Mono publisher to StepVerifier and expect it to<br>// terminate with error<br>Mono.error(new IllegalArgumentException(&quot;test error&quot;))<br>    .as(StepVerifier::create)<br>    .verifyError();<br><br>// Transform the error Mono publisher to StepVerifier and expect it to<br>// terminate with IllegalArgumentException error<br>Mono.error(new IllegalArgumentException(&quot;test error&quot;))<br>    .as(StepVerifier::create)<br>    .verifyError(IllegalArgumentException.class);</pre><h4>verifyErrorMessage</h4><p>StepVerifier.verifyErrorMessage() is used to verify error terminal signal with given message.</p><p><strong>Syntax:</strong></p><pre>Duration verifyErrorMessage(String errorMessage)</pre><p><strong>Example:</strong></p><pre>// Transform the error Mono publisher to StepVerifier and expect it to<br>// terminate with &quot;test error&quot; error message<br>Mono.error(new IllegalArgumentException(&quot;test error&quot;))<br>    .as(StepVerifier::create)<br>    .verifyErrorMessage(&quot;test error&quot;);</pre><h4>verifyErrorMatches</h4><p>StepVerifier.verifyErrorMatches() is used to verify error terminal signal matches given predicate.</p><p><strong>Syntax:</strong></p><pre>Duration verifyErrorMatches(Predicate&lt;Throwable&gt; predicate)</pre><p><strong>Example:</strong></p><pre>// Transform the error Mono publisher to StepVerifier and expect it to<br>// terminate with &quot;test error&quot; error message<br>Mono.error(new IllegalArgumentException(&quot;test error&quot;))<br>    .as(StepVerifier::create)<br>    .verifyErrorMatches(throwable -&gt; <br>            throwable instanceof IllegalArgumentException<br>            &amp;&amp; throwable.getMessage().equals(&quot;test error&quot;));</pre><h4>verifyErrorSatisfies</h4><p>With StepVerifier.verifyErrorMatches() the main problem is readability and assertion error message, which can be rectified by StepVerifier.verifyErrorSatisfies(). Using verifyErrorSatisfies we can easily write complex and custom assertions logic.</p><p><strong>Syntax:</strong></p><pre>Duration verifyErrorSatisfies(Consumer&lt;Throwable&gt; assertionConsumer)</pre><p><strong>Example:</strong></p><pre>// Transform the error Mono publisher to StepVerifier and expect it to<br>// terminate with error message ending with &quot;error&quot;<br>Mono.error(new IllegalArgumentException(&quot;test error&quot;))<br>    .as(StepVerifier::create)<br>    .verifyErrorSatisfies(throwable -&gt; assertThat(throwable)<br>        .isInstanceOf(IllegalArgumentException.class)<br>        .hasMessageEndingWith(&quot;error&quot;));</pre><h4>expectSubscription</h4><p>StepVerifier.expectSubscription() is used to verify subscribe signal.</p><p><strong>Syntax:</strong></p><pre>Step&lt;T&gt; expectSubscription()</pre><p><strong>Example:</strong></p><pre>Flux.just(1, 2, 3)<br>    .delayElements(Duration.ofSeconds(1))<br>    .as(StepVerifier::create)<br>    .expectSubscription()<br>    .expectNext(1, 2, 3)<br>    .verifyComplete();</pre><h4>expectNoEvent</h4><p>StepVerifier.expectNoEvent() is used to verify there should not be any signal/event emitted by the publisher for given duration.</p><p><strong>Syntax:</strong></p><pre>Step&lt;T&gt; expectNoEvent(Duration duration)</pre><p><strong>Example:</strong></p><pre>Flux.just(1, 2, 3)<br>    .delayElements(Duration.ofSeconds(1))<br>    .as(StepVerifier::create)<br>    .expectSubscription()<br>    .expectNoEvent(Duration.ofSeconds(1))<br>    .expectNext(1, 2, 3)<br>    .verifyComplete();</pre><h4>thenAwait</h4><p>StepVerifier.thenAwait() pauses the expectation evaluation for given duration. This method is mainly used with virtual time to advance time in controlled manner.</p><p><strong>Syntax:</strong></p><pre>Step&lt;T&gt; thenAwait(Duration timeshift)</pre><p><strong>Example:</strong></p><pre>Flux.just(1, 2, 3)<br>    .delayElements(Duration.ofSeconds(1))<br>    .as(StepVerifier::create)<br>    .expectSubscription()<br>    .thenAwait(Duration.ofSeconds(3))<br>    .expectNext(1, 2, 3)<br>    .verifyComplete();</pre><h4>withVirtualTime</h4><p>In reactive applications, operations often depend on time, such as delays, timeouts, or scheduling. Traditional testing approaches struggle with these aspects, as they typically require real-time delays, making tests non-deterministic and slow. Virtual time in StepVerifier addresses this challenge by simulating the passage of time in a controlled manner, without actually waiting for real time to elapse. This enables fast and deterministic testing of time-dependent operations.</p><p>To initialise a StepVerifier with virtual time capability, we need to make use of withVirtualTime() operator.</p><p><strong>Syntax:</strong></p><pre>static &lt;T&gt; FirstStep&lt;T&gt; withVirtualTime(<br>    Supplier&lt;? extends Publisher&lt;? extends T&gt;&gt; scenarioSupplier)</pre><p><strong>Example:</strong></p><pre>// Transform the Flux publisher of 10, 20 and 30 which emits elements every<br>// minute to StepVerifier with virtual time capability. Verifies publisher<br>// should emit last element 30 after 3 minutes of delay and terminates with<br>// complete signal but the overall verification should not take more than<br>// 500 milliseconds.<br><br>StepVerifier.withVirtualTime(() -&gt; Flux.just(10, 20, 30)<br>        .delayElements(Duration.ofMinutes(1)))<br>    .thenAwait(Duration.ofMinutes(2))<br>    .expectNextCount(2)<br>    .thenAwait(Duration.ofMinutes(1))<br>    .expectNext(30)<br>    .expectComplete()<br>    .verify(Duration.ofMillis(500));</pre><h4>Conclusion</h4><p>In this article, we explored essential StepVerifier operators which are essential and commonly used in across different scenarios. Proficiency in these concepts establishes a sturdy groundwork for proper unit testing reactive applications. While we’ve covered some of the key operators, there are many more to discover which will be found on the <a href="https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html">StepVerifier documentation</a>.</p><blockquote><em>This article is a segment of the </em><strong><em>Cooking up Reactivity: The Spring Way </em></strong><em>series. To explore the entire series, </em><a href="https://medium.com/@suman.maity112/list/cooking-up-reactivity-the-spring-way-0f5795367dfa"><em>click here</em></a><em>.</em></blockquote><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=fc23f57337b9" width="1" height="1" alt="">
